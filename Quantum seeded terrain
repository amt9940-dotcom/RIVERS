#!/usr/bin/env python3
"""
ðŸ”’ TOPOGRAPHY GENERATOR: LOCKED (DO NOT MODIFY)

Realistic terrain + stratigraphy with geologically-informed layer generation:
- Surface elevation map
- Stratigraphic cross-sections along X and Y axes
- Layers generated using USGS and sedimentology principles

GEOLOGICAL PRINCIPLES IMPLEMENTED:
=================================
Based on:
  - USGS Sediment Transport Guidelines
  - Boggs (2011) "Principles of Sedimentology and Stratigraphy" (7th ed.)
  - Tucker & Slingerland (1997) - Drainage basin responses to climate change
  - Dunne & Leopold (1978) - Water in Environmental Planning

Layer Generation Rules:
1. ELEVATION ZONES (absolute height above datum):
   - Lowlands (0-30% elevation): Fine sediments (clay, silt), wetland soils
   - Midlands (30-70% elevation): Mixed sediments (sand, loam), active deposition
   - Highlands (>70% elevation): Thin soils, exposed bedrock, coarse colluvium

2. SLOPE CONTROL (gradient-based energy):
   - Flat (<5Â°): Clay accumulation, wetland formation, thick soil development
   - Gentle (5-15Â°): Sand and silt deposition, stable soil profiles
   - Moderate (15-30Â°): Gravel/colluvium transport, thin soils
   - Steep (>30Â°): Bedrock exposure, minimal soil, active erosion

3. STRATIGRAPHIC RULES (Walther's Law - lateral facies = vertical sequence):
   Typical undisturbed sequence (top to bottom):
   - Topsoil (O/A horizon)
   - Subsoil (B horizon) 
   - Unconsolidated sediments (sand/silt/clay based on environment)
   - Weathered bedrock transition zone (saprolite/grus)
   - Competent bedrock

4. DEPOSITIONAL ENVIRONMENT MAPPING:
   - Alluvial (river channels): Gravel â†’ sand â†’ silt vertical fining
   - Lacustrine (lakes): Clay and silt in flat, low-energy zones
   - Colluvial (hillslopes): Poorly sorted, angular debris on slopes
   - Aeolian (wind): Well-sorted sand in low-vegetation areas
   - Residual (in-place weathering): Saprolite on stable, gentle slopes

Layer order (top â†’ bottom):
Topsoil, Subsoil, Colluvium, Saprolite, WeatheredBR (rind/grus),
Sandstone, Shale, Limestone, Basement, BasementFloor
(+ Alluvium, Clay, Silt, Sand, Till, Loess, and other deposits)
"""
from __future__ import annotations

# ------------------------- Standard imports -------------------------
import numpy as np
import matplotlib.pyplot as plt

# Optional quantum seeding (no auto-install)
try:
    import qiskit  # type: ignore  # noqa
    from qiskit import QuantumCircuit  # type: ignore  # noqa
    try:
        import qiskit_aer  # type: ignore  # noqa
        HAVE_QISKIT = True
    except Exception:
        HAVE_QISKIT = False
except Exception:
    HAVE_QISKIT = False
    QuantumCircuit = None  # type: ignore  # noqa


def qrng_uint32(n, nbits=32):
  """Return n uint32 from Qiskit Aer if available; else PRNG fallback."""
  if not HAVE_QISKIT:
      return np.random.default_rng().integers(0, 2**32, size=n, dtype=np.uint32)
  try:
      from qiskit_aer import Aer  # type: ignore  # noqa
  except Exception:
      try:
          from qiskit import Aer  # type: ignore  # noqa
      except Exception:
          return np.random.default_rng().integers(0, 2**32, size=n, dtype=np.uint32)
  qc = QuantumCircuit(nbits, nbits)
  qc.h(range(nbits)); qc.measure(range(nbits), range(nbits))
  backend = Aer.get_backend("qasm_simulator")
  import os
  seed_sim = int.from_bytes(os.urandom(4), "little")
  job = backend.run(qc, shots=n, memory=True, seed_simulator=seed_sim)
  mem = job.result().get_memory(qc)
  return np.array([np.uint32(int(bits[::-1], 2)) for bits in mem], dtype=np.uint32)

def rng_from_qrng(n_seeds=4, random_seed=None):
  """Random per run if random_seed=None; reproducible if you pass an int."""
  if random_seed is not None:
      return np.random.default_rng(int(random_seed))
  import os, time, hashlib
  seeds = qrng_uint32(n_seeds).tobytes()
  mix = seeds + os.urandom(16) + int(time.time_ns()).to_bytes(8, "little")
  h = hashlib.blake2b(mix, digest_size=8).digest()
  return np.random.default_rng(int.from_bytes(h, "little"))


# ========================================================================================
# ðŸ”’ TOPOGRAPHY GENERATOR - DO NOT MODIFY THIS SECTION ðŸ”’
# ========================================================================================
# This section produces realistic elevation and slope data.
# The layer generator receives heightmap and slope as INPUT ONLY.
# ========================================================================================

def fractional_surface(N, beta=3.1, rng=None):
  """Power-law spectrum; higher beta => smoother large-scale terrain."""
  rng = rng or np.random.default_rng()
  kx = np.fft.fftfreq(N); ky = np.fft.rfftfreq(N)
  K = np.sqrt(kx[:, None]**2 + ky[None, :]**2); K[0, 0] = np.inf
  amp = 1.0 / (K ** (beta/2))
  phase = rng.uniform(0, 2*np.pi, size=(N, ky.size))
  spec = amp * (np.cos(phase) + 1j*np.sin(phase)); spec[0, 0] = 0.0
  z = np.fft.irfftn(spec, s=(N, N), axes=(0, 1))
  lo, hi = np.percentile(z, [2, 98])
  return np.clip((z - lo)/(hi - lo + 1e-12), 0, 1)


def bilinear_sample(img, X, Y):
  N = img.shape[0]
  x0 = np.floor(X).astype(int) % N; y0 = np.floor(Y).astype(int) % N
  x1 = (x0+1) % N; y1 = (y0+1) % N
  dx = X - np.floor(X); dy = Y - np.floor(Y)
  return ((1-dx)*(1-dy)*img[x0,y0] + dx*(1-dy)*img[x1,y0] +
          (1-dx)*dy*img[x0,y1] + dx*dy*img[x1,y1])


def domain_warp(z, rng, amp=0.12, beta=3.0):
  """Coordinate distortion; ampâ†‘ => gnarlier micro-relief."""
  N = z.shape[0]
  u = fractional_surface(N, beta=beta, rng=rng)*2 - 1
  v = fractional_surface(N, beta=beta, rng=rng)*2 - 1
  ii, jj = np.meshgrid(np.arange(N), np.arange(N), indexing="ij")
  Xw = (ii + amp*N*u) % N; Yw = (jj + amp*N*v) % N
  return bilinear_sample(z, Xw, Yw)


def ridged_mix(z, alpha=0.18):
  """Ridge/valley sharpening; alphaâ†‘ => craggier."""
  ridged = 1.0 - np.abs(2.0*z - 1.0)
  out = (1-alpha)*z + alpha*ridged
  lo, hi = np.percentile(out, [2, 98])
  return np.clip((out - lo)/(hi - lo + 1e-12), 0, 1)


def lowpass2d(z, cutoff=None, rolloff=0.08):
    """Set cutoff (0..0.5) for smoothing; None disables."""
    if cutoff is None:
        return z
    Nx, Ny = z.shape
    Z = np.fft.rfft2(z)
    kx = np.fft.fftfreq(Nx)[:, None]
    ky = np.fft.rfftfreq(Ny)[None, :]
    r = np.sqrt(kx**2 + ky**2)

    m = np.ones_like(r)
    r0, w = float(cutoff), float(rolloff)
    in_roll = (r > r0) & (r < r0 + w)
    m[r >= r0 + w] = 0.0
    m[in_roll] = 0.5 * (1 + np.cos(np.pi * (r[in_roll] - r0) / w))

    zf = np.fft.irfft2(Z * m, s=z.shape)
    lo, hi = np.percentile(zf, [2, 98])
    return np.clip((zf - lo) / (hi - lo + 1e-12), 0, 1)


def gaussian_blur(z, sigma=None):
  if sigma is None or sigma <= 0: return z
  rad = int(np.ceil(3*sigma)); x = np.arange(-rad, rad+1)
  g = np.exp(-0.5*(x/sigma)**2); g /= g.sum()
  tmp = np.zeros_like(z)
  for i,w in enumerate(g): tmp += w*np.roll(z, i-rad, axis=1)
  out = np.zeros_like(z)
  for i,w in enumerate(g): out += w*np.roll(tmp, i-rad, axis=0)
  lo, hi = np.percentile(out, [2,98])
  return np.clip((out - lo)/(hi - lo + 1e-12), 0, 1)


def quantum_seeded_topography(
  N=512, beta=3.1, warp_amp=0.12, ridged_alpha=0.18,
  *, random_seed=None, smooth_cutoff=None, smooth_rolloff=0.08, post_blur_sigma=None
):
  """
  ðŸ”’ LOCKED TOPOGRAPHY GENERATOR ðŸ”’
  
  Generates realistic elevation and slope data using quantum-seeded randomness
  and fractal terrain generation. This function MUST NOT BE MODIFIED.
  
  Returns:
    z (ndarray): Normalized elevation map (0-1)
    rng (Generator): Random number generator for downstream use
  """
  rng = rng_from_qrng(n_seeds=4, random_seed=random_seed)
  base_low  = fractional_surface(N, beta=beta,     rng=rng)
  base_high = fractional_surface(N, beta=beta-0.4, rng=rng)
  z = 0.65*base_low + 0.35*base_high
  z = domain_warp(z, rng=rng, amp=warp_amp, beta=beta)
  z = ridged_mix(z, alpha=ridged_alpha)
  z = lowpass2d(z, cutoff=smooth_cutoff, rolloff=smooth_rolloff)
  z = gaussian_blur(z, sigma=post_blur_sigma)
  return z, rng

# ========================================================================================
# END OF LOCKED TOPOGRAPHY GENERATOR
# ========================================================================================


# ---------------------- Stratigraphy utilities ----------------------
def _box_blur(a, k=5):
  if k <= 1: return a
  out = a.copy()
  for axis in (0,1):
      tmp = out; s = np.zeros_like(tmp)
      for i in range(-(k//2), k//2+1): s += np.roll(tmp, i, axis=axis)
      out = s/float(k)
  return out


def _normalize(x, eps=1e-12):
  lo, hi = np.percentile(x, [2,98])
  return np.clip((x - lo)/(hi - lo + eps), 0.0, 1.0)

# --------------- Wind-relevant geological features -------------------
def compute_topo_fields(surface_elev, pixel_scale_m):
    """
    Basic topographic fields from elevation only.

    Returns dict with:
      E, E_norm          : elevation (m) and normalized (0..1)
      dEx, dEy           : gradients in x (cols) and y (rows) (m/m)
      slope_mag, slope_norm
      aspect             : downslope direction (radians, 0 = +x)
      laplacian          : convex/concave indicator
    """
    E = surface_elev
    E_norm = _normalize(E)

    # gradient: np.gradient returns [d/drow, d/dcol] = [y, x]
    dEy, dEx = np.gradient(E, pixel_scale_m, pixel_scale_m)
    slope_mag = np.hypot(dEx, dEy) + 1e-12
    slope_norm = _normalize(slope_mag)

    # downslope aspect (for windward/leeward logic later)
    aspect = np.arctan2(-dEy, -dEx)

    # simple 4-neighbor Laplacian: <0 convex (ridge), >0 concave (valley)
    up    = np.roll(E, -1, axis=0)
    down  = np.roll(E,  1, axis=0)
    left  = np.roll(E,  1, axis=1)
    right = np.roll(E, -1, axis=1)
    lap = (up + down + left + right - 4.0 * E) / (pixel_scale_m**2)

    return {
        "E": E,
        "E_norm": E_norm,
        "dEx": dEx,
        "dEy": dEy,
        "slope_mag": slope_mag,
        "slope_norm": slope_norm,
        "aspect": aspect,
        "laplacian": lap,
    }


def classify_windward_leeward(dEx, dEy, slope_norm,
                              base_wind_dir_deg,
                              slope_min=0.15):
    """
    Per-cell windward / leeward classification.

    base_wind_dir_deg : direction FROM WHICH the wind blows (0Â° = +x, 90Â° = +y)
    slope_min         : ignore very flat cells
    """
    theta = np.deg2rad(base_wind_dir_deg)
    wx, wy = np.cos(theta), np.sin(theta)   # wind-from unit vector

    # component of gradient along wind-from direction
    # >0: terrain rises into the wind (windward); <0: drops away (leeward)
    up_component = dEx * wx + dEy * wy

    slope_enough = slope_norm >= slope_min
    windward_mask = slope_enough & (up_component > 0.0)
    leeward_mask  = slope_enough & (up_component < 0.0)

    return windward_mask, leeward_mask, up_component

def classify_wind_barriers(E_norm, slope_norm, laplacian, up_component,
                           elev_thresh=0.5,
                           slope_thresh=0.4,
                           convex_frac=0.4,
                           up_quantile=0.4):
    """
    Wind barriers: mountain walls that strongly lift/deflect flow.

    Conditions (now a bit looser):
      - moderately high elevation (E_norm >= elev_thresh)
      - moderately steep slopes (slope_norm >= slope_thresh)
      - convex curvature (ridge-like)
      - reasonably strong upslope component along wind
    """
    # convex threshold (more negative laplacian = more ridge-like)
    lap_convex_thr = np.quantile(laplacian, convex_frac)

    # only consider positive upslope; choose upper quantile as "strong" barrier
    mask_pos = up_component > 0.0
    if np.any(mask_pos):
        up_thr = np.quantile(up_component[mask_pos], up_quantile)
    else:
        up_thr = 0.0  # fallback: any positive upslope can count

    barrier_mask = (
        (E_norm      >= elev_thresh) &
        (slope_norm  >= slope_thresh) &
        (laplacian   <= lap_convex_thr) &
        (up_component >= up_thr)
    )
    return barrier_mask

def classify_wind_channels(E_norm, slope_norm, laplacian,
                           dEx, dEy,
                           base_wind_dir_deg,
                           elev_max=0.7,
                           concave_frac=0.6,
                           slope_min=0.03,
                           slope_max=0.7,
                           align_thresh_deg=45.0):
    """
    Wind channels: valley axes that guide flow.

    Looser conditions:
      - low to mid elevation (E_norm <= elev_max)
      - gentle to moderately steep slopes
      - concave curvature
      - downslope direction roughly ALIGNED with wind direction
    """
    theta = np.deg2rad(base_wind_dir_deg)
    wx, wy = np.cos(theta), np.sin(theta)

    # downslope direction vector
    fx, fy = -dEx, -dEy
    magf = np.hypot(fx, fy) + 1e-12
    fxu, fyu = fx / magf, fy / magf

    # cosine of angle between downslope and wind direction
    cos_ang = fxu * wx + fyu * wy
    cos_align = np.cos(np.deg2rad(align_thresh_deg))

    # concave valleys
    lap_concave_thr = np.quantile(laplacian, concave_frac)

    channel_mask = (
        (E_norm      <= elev_max) &
        (slope_norm  >= slope_min) &
        (slope_norm  <= slope_max) &
        (laplacian   >= lap_concave_thr) &
        (cos_ang     >= cos_align)
    )
    return channel_mask


def classify_basins(E_norm, slope_norm, laplacian,
                    elev_max=0.5,
                    slope_max=0.3,
                    concave_frac=0.6):
    """
    Basins / bowls:
      - relatively low elevation
      - gentle slopes
      - concave (bowls)
    (Looser thresholds so we actually catch some.)
    """
    lap_concave_thr = np.quantile(laplacian, concave_frac)
    basin_mask = (
        (E_norm      <= elev_max) &
        (slope_norm  <= slope_max) &
        (laplacian   >= lap_concave_thr)
    )
    return basin_mask


def extract_region_summaries(mask, surface_elev, pixel_scale_m, min_cells=3):
    """
    Connected-component labeling for a boolean mask.

    Uses 8-neighbor connectivity so long skinny ridges/valleys are treated
    as single structures instead of many tiny diagonal fragments.

    Each region becomes a 'structure' with:
      - indices        : (N_i, 2) array of (row, col)
      - centroid_rc    : (row, col) center
      - size_cells     : area in cells
      - mean/max/min elevation, relief
      - orientation_rad: main axis orientation (0 = +x)
      - length_scale_m : rough length along main axis (m)
    """
    ny, nx = mask.shape
    visited = np.zeros_like(mask, dtype=bool)
    regions = []

    for r0 in range(ny):
        for c0 in range(nx):
            if not mask[r0, c0] or visited[r0, c0]:
                continue

            # flood-fill with 8-neighbor connectivity
            stack = [(r0, c0)]
            visited[r0, c0] = True
            cells = []

            while stack:
                r, c = stack.pop()
                cells.append((r, c))

                for dr in (-1, 0, 1):
                    for dc in (-1, 0, 1):
                        if dr == 0 and dc == 0:
                            continue
                        rr, cc = r + dr, c + dc
                        if (
                            0 <= rr < ny and 0 <= cc < nx and
                            mask[rr, cc] and not visited[rr, cc]
                        ):
                            visited[rr, cc] = True
                            stack.append((rr, cc))

            idxs = np.array(cells, dtype=int)
            if idxs.shape[0] < min_cells:
                continue

            rows = idxs[:, 0].astype(float)
            cols = idxs[:, 1].astype(float)
            centroid_r = rows.mean()
            centroid_c = cols.mean()

            vals = surface_elev[idxs[:, 0], idxs[:, 1]]
            mean_e = float(vals.mean())
            max_e  = float(vals.max())
            min_e  = float(vals.min())
            relief = max_e - min_e

            # PCA for main axis orientation / length
            x = cols - centroid_c
            y = rows - centroid_r
            C = np.cov(np.vstack([x, y]))
            eigvals, eigvecs = np.linalg.eigh(C)
            i_max = int(np.argmax(eigvals))
            v = eigvecs[:, i_max]
            orientation = float(np.arctan2(v[1], v[0]))
            length_scale = float(2.0 * np.sqrt(max(eigvals[i_max], 0.0)) * pixel_scale_m)

            regions.append({
                "indices": idxs,
                "centroid_rc": (float(centroid_r), float(centroid_c)),
                "size_cells": int(idxs.shape[0]),
                "mean_elev_m": mean_e,
                "max_elev_m": max_e,
                "min_elev_m": min_e,
                "relief_m": relief,
                "orientation_rad": orientation,
                "length_scale_m": length_scale,
            })

    return regions


def build_wind_structures(surface_elev, pixel_scale_m, base_wind_dir_deg):
    """
    Given a topography map, classify only geological structures that change wind:
      - windward / leeward slopes
      - wind barriers (mountain walls)
      - wind channels (valley corridors)
      - basins / bowls (air pooling zones)

    Returns a dict with per-cell masks and grouped regions.
    Does NOT modify terrain or simulate weather.
    """
    topo = compute_topo_fields(surface_elev, pixel_scale_m)
    E        = topo["E"]
    E_norm   = topo["E_norm"]
    dEx      = topo["dEx"]
    dEy      = topo["dEy"]
    slope_n  = topo["slope_norm"]
    aspect   = topo["aspect"]
    lap      = topo["laplacian"]

    windward_mask, leeward_mask, up_component = classify_windward_leeward(
        dEx, dEy, slope_n, base_wind_dir_deg
    )

    barrier_mask = classify_wind_barriers(
        E_norm, slope_n, lap, up_component
    )

    channel_mask = classify_wind_channels(
        E_norm, slope_n, lap, dEx, dEy, base_wind_dir_deg
    )

    basin_mask = classify_basins(
        E_norm, slope_n, lap
    )

    barrier_regions = extract_region_summaries(barrier_mask, E, pixel_scale_m, min_cells=10)
    channel_regions = extract_region_summaries(channel_mask, E, pixel_scale_m, min_cells=10)
    basin_regions   = extract_region_summaries(basin_mask,   E, pixel_scale_m, min_cells=10)


    return {
        "E": E,
        "E_norm": E_norm,
        "slope_norm": slope_n,
        "aspect": aspect,
        "laplacian": lap,

        "windward_mask": windward_mask,
        "leeward_mask": leeward_mask,
        "up_component": up_component,

        "barrier_mask": barrier_mask,
        "channel_mask": channel_mask,
        "basin_mask": basin_mask,

        "barrier_regions": barrier_regions,   # mountain walls that block/deflect flow
        "channel_regions": channel_regions,   # valley corridors that funnel flow
        "basin_regions": basin_regions,       # bowls where air/storms pool

        "meta": {
            "pixel_scale_m": pixel_scale_m,
        },
    }


# -------------------- Wind / pseudo-low-pressure helpers --------------------
def compute_orographic_low_pressure(
    surface_elev,
    rng,
    pixel_scale_m,
    base_wind_dir_deg=45.0,
    mode="day",               # "day" ~ valley breeze, "night" ~ mountain breeze, "mixed"
    smooth_scale_rel=0.20,    # fraction of domain for large-scale smoothing
):
    """
    Build a 0..1 'low-pressure likelihood' map over mountains WITHOUT
    explicitly storing pressure, using only terrain geometry + wind direction.

    Concept:
    - Wind is driven from higher-pressure to lower-pressure areas.
      We don't model pressure; instead we mark where low-pressure *would* occur
      (ridges on windward side, heated slopes by day, cold pooled valleys at night).
    - Mountains force air to rise on windward slopes => effective low-P there.
    - Daytime: valley breeze -> upslope flow, low-P near heated slopes & ridges.
    - Nighttime: mountain breeze -> downslope flow, low-P in cold pooled valleys.

    Inputs
    ------
    surface_elev : 2D array of absolute elevation (m)
    rng          : np.random.Generator (Qiskit-seeded in your code)
    pixel_scale_m: grid spacing (m)
    base_wind_dir_deg : mean large-scale wind direction *from which* air comes
                        (0Â° = +x, 90Â° = +y)
    mode         : "day", "night", or "mixed"
    smooth_scale_rel : how coarse the large-scale basin/high field is (0..1)
    """
    z = surface_elev
    ny, nx = z.shape

    # --- gradient & slope ---
    dzdx, dzdy = np.gradient(z, pixel_scale_m, pixel_scale_m)
    slope_mag = np.sqrt(dzdx**2 + dzdy**2) + 1e-12
    slope_n   = _normalize(slope_mag)
    gentle    = 1.0 - slope_n

    # --- basic elevation normalization / basins vs highs ---
    z_smooth_k = max(5, int(smooth_scale_rel * min(nx, ny)) | 1)
    z_smooth   = _box_blur(z, k=z_smooth_k)

    elev_n = _normalize(z)            # 0 low â†’ 1 high
    highs  = _normalize(z_smooth)     # broad highs (ridges, plateaus)
    basins = _normalize(1.0 - z_smooth)  # broad valleys/depressions

    # --- large-scale wind direction (unit vector) ---
    # wind blows from this direction into the domain
    az = np.deg2rad(base_wind_dir_deg)
    wx, wy = np.cos(az), np.sin(az)

    # directional derivative of elevation along wind direction:
    # positive where flow goes upslope (orographic lifting on windward side)
    dzw = dzdx * wx + dzdy * wy
    orographic_raw = np.maximum(dzw, 0.0)   # only upslope component
    orographic = _normalize(orographic_raw)

    # --- valley vs mountain breeze components ---
    # day: slopes heated, air rises -> low-P along sun-facing + valley-slopes
    # night: air cools, drains into valleys -> low-P pooled in basins

    # treat "sun direction" similar to wind_dir for now; you can make it separate later
    sx, sy = wx, wy
    dzs = dzdx * sx + dzdy * sy
    sun_slope_raw = np.maximum(dzs, 0.0)    # slopes facing the "sun"
    sun_slope = _normalize(sun_slope_raw)

    # Daytime valley-breeze low-P:
    # - on heated, sun-facing slopes (sun_slope)
    # - near ridge tops / high terrain (highs)
    lowP_day = _normalize(0.5 * sun_slope + 0.5 * highs)

    # Nighttime mountain-breeze low-P:
    # - in basins/valleys (basins)
    # - where slopes are gentle (cold air accumulates more easily)
    lowP_night = _normalize(0.7 * basins + 0.3 * gentle)

    # --- combine with orographic lifting (always present if mountains + wind) ---
    mode = str(mode).lower()
    if mode == "day":
        lowP = 0.50 * orographic + 0.50 * lowP_day
    elif mode == "night":
        lowP = 0.40 * orographic + 0.60 * lowP_night
    else:  # "mixed"
        lowP = 0.40 * orographic + 0.30 * lowP_day + 0.30 * lowP_night

    # small quantum-random perturbation, smoothed so it doesn't make 'salt & pepper'
    k_noise = max(7, int(0.05 * min(nx, ny)) | 1)
    rnd = rng.standard_normal(size=z.shape)
    rnd_smooth = _box_blur(rnd, k=k_noise)
    rnd_smooth = rnd_smooth / (np.std(rnd_smooth) + 1e-9)

    lowP += 0.15 * rnd_smooth  # gentle perturbation
    lowP = _normalize(lowP)

    return lowP  # 0..1: higher = more likely effective low-pressure zone


# ========================================================================================
# âœ… IMPROVED LAYER GENERATOR - Based on USGS & Geologic Principles
# ========================================================================================
# This section uses elevation and slope from the topography generator to create
# realistic geological layers following sedimentology and stratigraphy principles.
# ========================================================================================

def classify_elevation_zones(E_norm):
    """
    Classify terrain into elevation zones for depositional environment mapping.
    
    USGS Classification (adapted for terrain modeling):
    - Lowlands (0-30%): Valley floors, floodplains, lakes - fine sediments accumulate
    - Midlands (30-70%): Hillslopes, terraces - mixed sediment transport and deposition  
    - Highlands (>70%): Mountain peaks, ridges - erosion dominates, bedrock exposure
    
    Reference: USGS Digital Elevation Model (DEM) classification standards
    """
    lowlands = E_norm <= 0.30
    midlands = (E_norm > 0.30) & (E_norm <= 0.70)
    highlands = E_norm > 0.70
    
    return {
        "lowlands": lowlands,
        "midlands": midlands, 
        "highlands": highlands,
        "elevation_factor": E_norm
    }


def classify_slope_regimes(slope_mag_deg):
    """
    Classify terrain by slope angle to determine depositional vs. erosional zones.
    
    Geomorphic slope classification (Dunne & Leopold, 1978):
    - Flat (0-5Â°): Deposition zones - clay, silt accumulation, wetlands
    - Gentle (5-15Â°): Stable slopes - sand deposition, soil development
    - Moderate (15-30Â°): Transport slopes - gravel/colluvium, thin soils
    - Steep (>30Â°): Erosion zones - bedrock exposure, negligible sediment cover
    
    Reference: Dunne & Leopold (1978) "Water in Environmental Planning"
    """
    flat = slope_mag_deg <= 5.0
    gentle = (slope_mag_deg > 5.0) & (slope_mag_deg <= 15.0)
    moderate = (slope_mag_deg > 15.0) & (slope_mag_deg <= 30.0)
    steep = slope_mag_deg > 30.0
    
    # Erosion factor: increases with slope (limits soil/sediment thickness)
    erosion_factor = np.clip(slope_mag_deg / 45.0, 0.0, 1.0)
    
    return {
        "flat": flat,
        "gentle": gentle,
        "moderate": moderate,
        "steep": steep,
        "erosion_factor": erosion_factor
    }


def compute_depositional_environments(E_norm, slope_norm, laplacian, rng):
    """
    Map depositional environments based on elevation, slope, and topographic curvature.
    
    Uses Walther's Law: lateral facies changes = vertical facies sequences
    (Boggs 2011, "Principles of Sedimentology and Stratigraphy")
    
    Environments:
    1. Lacustrine (lakes): Low elevation + flat + concave (basins)
    2. Fluvial (rivers): Low-mid elevation + gentle-moderate slope + linear
    3. Colluvial (hillslope): Mid elevation + moderate-steep slope
    4. Aeolian (desert/dune): Low-mid elevation + gentle slope + convex
    5. Residual (weathering): Stable high elevation + gentle slope
    """
    # Curvature classification
    concave = laplacian > 0  # Valleys, depressions
    convex = laplacian < 0   # Ridges, hilltops
    
    # Lacustrine: deep basins with flat terrain
    lacustrine = (E_norm < 0.35) & (slope_norm < 0.15) & concave
    
    # Fluvial: valley floors and gentle slopes (channels and floodplains)
    fluvial = (E_norm < 0.60) & (slope_norm > 0.05) & (slope_norm < 0.35) & concave
    
    # Colluvial: hillslopes with moderate to steep gradients
    colluvial = (E_norm > 0.25) & (slope_norm > 0.25)
    
    # Aeolian: low relief, gentle convex areas (potential dune fields)
    aeolian = (E_norm < 0.50) & (slope_norm < 0.20) & convex
    
    # Residual weathering: stable, gently sloping highlands
    residual = (E_norm > 0.60) & (slope_norm < 0.30)
    
    return {
        "lacustrine": lacustrine,
        "fluvial": fluvial,
        "colluvial": colluvial,
        "aeolian": aeolian,
        "residual": residual
    }


def generate_sand_layer(env, slope_class, E_norm, rng, max_thickness=25.0):
    """
    Generate sand layer thickness based on realistic depositional controls.
    
    SAND DEPOSITION RULES (USGS Sediment Transport):
    - Forms in moderate-energy environments: rivers, beaches, dunes
    - Requires: low-moderate slopes (<15Â°), adequate sediment supply
    - Thickness: greatest in channels and dune fields
    - Grain size: medium to coarse (0.0625-2 mm)
    
    Favorable locations:
    â€¢ River channels (fluvial environment)
    â€¢ Beach/dune systems (aeolian + low elevation)
    â€¢ Alluvial fans (moderate slopes at highland margins)
    
    Reference: USGS Professional Paper 1396 (Sediment Transport)
    """
    # Sand favorability index
    sand_favor = np.zeros_like(E_norm)
    
    # 1. Fluvial sand (river channels) - PRIMARY
    sand_favor += 0.80 * env["fluvial"].astype(float)
    
    # 2. Aeolian sand (dunes) - SECONDARY  
    sand_favor += 0.60 * env["aeolian"].astype(float) * (E_norm < 0.40)
    
    # 3. Alluvial fans (highland margins with moderate slope)
    alluvial_fan = (E_norm > 0.50) & (E_norm < 0.75) & slope_class["moderate"]
    sand_favor += 0.50 * alluvial_fan.astype(float)
    
    # 4. Suppress on steep slopes and very high elevations
    sand_favor *= (1.0 - slope_class["erosion_factor"]**1.5)
    sand_favor *= np.clip(1.5 - E_norm, 0.0, 1.0)
    
    # Normalize and apply thickness
    sand_favor = _normalize(sand_favor)
    
    # Add spatial variability (channel meanders, dune patterns)
    noise = rng.lognormal(mean=0.0, sigma=0.30, size=E_norm.shape)
    sand_favor_noisy = _normalize(sand_favor * noise)
    
    thickness = max_thickness * sand_favor_noisy
    return np.maximum(thickness, 0.0)


def generate_clay_layer(env, slope_class, E_norm, rng, max_thickness=20.0):
    """
    Generate clay layer thickness based on low-energy depositional settings.
    
    CLAY DEPOSITION RULES (Boggs 2011):
    - Forms in LOW-ENERGY environments: lakes, floodplains, deep ocean
    - Requires: flat terrain (<5Â° slope), standing/slow-moving water
    - Grain size: <0.004 mm (settles only in still water)
    - Thickness: greatest in lake centers and floodplain backswamps
    
    Favorable locations:
    â€¢ Lake bottoms (lacustrine + flat + low elevation)
    â€¢ Floodplain backswamps (fluvial + very flat)
    â€¢ Wetlands (low elevation + concave + flat)
    
    Reference: Boggs (2011) Ch. 4 - Clastic Sedimentary Rocks
    """
    clay_favor = np.zeros_like(E_norm)
    
    # 1. Lacustrine clay (lake bottoms) - PRIMARY
    clay_favor += 0.90 * env["lacustrine"].astype(float) * slope_class["flat"].astype(float)
    
    # 2. Floodplain clay (overbank deposits) - SECONDARY
    clay_favor += 0.70 * env["fluvial"].astype(float) * slope_class["flat"].astype(float)
    
    # 3. Must be in lowlands (clay doesn't form on highlands)
    clay_favor *= (E_norm < 0.40)
    
    # 4. Strong suppression on ANY slope
    clay_favor *= (1.0 - slope_class["erosion_factor"]**2)
    
    clay_favor = _normalize(clay_favor)
    
    # Minimal noise (clay layers are laterally continuous)
    noise = rng.lognormal(mean=0.0, sigma=0.15, size=E_norm.shape)
    clay_favor_noisy = _normalize(clay_favor * noise)
    
    thickness = max_thickness * clay_favor_noisy
    return np.maximum(thickness, 0.0)


def generate_silt_layer(env, slope_class, E_norm, rng, max_thickness=15.0):
    """
    Generate silt layer thickness - intermediate between clay and sand.
    
    SILT DEPOSITION RULES:
    - Forms in low-moderate energy environments
    - Grain size: 0.004-0.0625 mm (settles in slow currents)
    - Common in: floodplains, lake margins, estuaries, loess deposits
    
    Favorable locations:
    â€¢ Distal floodplains (beyond active channels)
    â€¢ Lake margins (transition from clay to sand)
    â€¢ Wind-blown loess on uplands (aeolian silt)
    
    Reference: USGS - Grain Size Classification
    """
    silt_favor = np.zeros_like(E_norm)
    
    # 1. Fluvial silt (floodplains) - PRIMARY
    silt_favor += 0.75 * env["fluvial"].astype(float) * slope_class["gentle"].astype(float)
    
    # 2. Lake margin silt
    lake_margin = env["lacustrine"].astype(float) * (slope_class["gentle"].astype(float))
    silt_favor += 0.65 * lake_margin
    
    # 3. Loess (wind-blown silt on uplands)
    loess_zone = (E_norm > 0.40) & (E_norm < 0.70) & slope_class["gentle"]
    silt_favor += 0.50 * loess_zone.astype(float)
    
    # 4. Moderate slope sensitivity
    silt_favor *= (1.0 - slope_class["erosion_factor"]**1.2)
    
    silt_favor = _normalize(silt_favor)
    
    noise = rng.lognormal(mean=0.0, sigma=0.25, size=E_norm.shape)
    silt_favor_noisy = _normalize(silt_favor * noise)
    
    thickness = max_thickness * silt_favor_noisy
    return np.maximum(thickness, 0.0)


def generate_gravel_layer(env, slope_class, E_norm, rng, max_thickness=12.0):
    """
    Generate gravel layer thickness - high-energy coarse clastic deposits.
    
    GRAVEL DEPOSITION RULES (Boggs 2011):
    - Requires HIGH-ENERGY flow: steep channels, alluvial fans, glacial outwash
    - Grain size: >2 mm (cobbles, pebbles)
    - Typically found: near sediment sources (mountains, eroding bedrock)
    - Forms basal lag deposits in channels
    
    Favorable locations:
    â€¢ Mountain-front alluvial fans (moderate-steep slopes)
    â€¢ Active stream channels (high gradient)
    â€¢ Glacial outwash plains (if till present)
    
    Reference: Boggs (2011) Ch. 5 - Conglomerates
    """
    gravel_favor = np.zeros_like(E_norm)
    
    # 1. Alluvial fans (mountain fronts)
    alluvial_fan = (E_norm > 0.50) & (E_norm < 0.80) & slope_class["moderate"]
    gravel_favor += 0.85 * alluvial_fan.astype(float)
    
    # 2. High-gradient channels
    steep_channel = env["fluvial"].astype(float) * slope_class["moderate"].astype(float)
    gravel_favor += 0.70 * steep_channel
    
    # 3. Colluvial gravel (hillslope debris)
    gravel_favor += 0.55 * env["colluvial"].astype(float) * (slope_class["moderate"] | slope_class["steep"]).astype(float)
    
    # 4. Requires proximity to highlands (sediment source)
    source_proximity = np.clip(E_norm, 0.3, 1.0)  # Favor mid-high elevations
    gravel_favor *= source_proximity
    
    gravel_favor = _normalize(gravel_favor)
    
    # High variability (gravel deposits are patchy)
    noise = rng.lognormal(mean=0.0, sigma=0.45, size=E_norm.shape)
    gravel_favor_noisy = _normalize(gravel_favor * noise)
    
    thickness = max_thickness * gravel_favor_noisy
    return np.maximum(thickness, 0.0)


def generate_topsoil_layer(E_norm, slope_class, rng, base_thickness=(0.3, 1.8)):
    """
    Generate topsoil (O/A horizon) thickness based on slope and vegetation potential.
    
    SOIL HORIZON RULES (USDA Soil Taxonomy):
    - O/A horizon: Organic matter + mineral soil
    - Thickness controlled by: slope stability, vegetation, climate, time
    - Thickest on: stable, gentle slopes with vegetation
    - Absent on: steep slopes (>30Â°), bare bedrock, active erosion zones
    
    Reference: USDA Natural Resources Conservation Service - Soil Survey Manual
    """
    min_thick, max_thick = base_thickness
    
    # Base thickness inversely related to slope
    thickness = max_thick - (max_thick - min_thick) * slope_class["erosion_factor"]
    
    # Zero thickness on steep slopes and very high elevations (alpine/bare rock)
    thickness *= (~slope_class["steep"]).astype(float)
    thickness *= np.clip(1.2 - E_norm, 0.0, 1.0)  # Thin out above treeline
    
    # Smooth to represent vegetation-driven continuity
    thickness = _box_blur(thickness, k=5)
    
    return np.maximum(thickness, 0.0)


def generate_colluvium_layer(E_norm, slope_class, laplacian, rng, max_thickness=18.0):
    """
    Generate colluvium thickness - gravity-driven hillslope deposits.
    
    COLLUVIUM FORMATION (Geomorphology principles):
    - Unconsolidated, poorly sorted sediment moved by gravity
    - Accumulates at: slope bases, hollows, concave hillslopes
    - Thickness increases with: slope length, hollow convergence
    - Absent on: ridges, steep bedrock slopes
    
    Reference: Selby (1993) "Hillslope Materials and Processes"
    """
    # Colluvium accumulates in topographic hollows (concave areas)
    hollows = laplacian > 0
    hollow_strength = _normalize(np.maximum(laplacian, 0.0))
    
    # Favors mid-slopes (not ridgetops, not valley floors)
    mid_slope = (E_norm > 0.30) & (E_norm < 0.80)
    
    # Gentle to moderate slopes (too flat = no transport, too steep = no accumulation)
    good_slope = slope_class["gentle"] | slope_class["moderate"]
    
    colluvium_favor = hollow_strength * mid_slope.astype(float) * good_slope.astype(float)
    
    # Smooth to represent downslope creep patterns
    colluvium_favor = _box_blur(colluvium_favor, k=7)
    colluvium_favor = _normalize(colluvium_favor)
    
    # Add noise
    noise = rng.lognormal(mean=0.0, sigma=0.25, size=E_norm.shape)
    colluvium_favor_noisy = _normalize(colluvium_favor * noise)
    
    thickness = max_thickness * colluvium_favor_noisy
    return np.maximum(thickness, 0.0)


def generate_saprolite_layer(E_norm, slope_class, rng, median_m=6.0, clamp=(0.5, 30.0)):
    """
    Generate saprolite (weathered bedrock) thickness.
    
    SAPROLITE FORMATION (Weathering geomorphology):
    - Chemically weathered bedrock that retains original structure
    - Thickness controlled by: weathering rate vs. erosion rate
    - Thickest on: stable, gently sloping interfluves (old surfaces)
    - Thin/absent on: steep slopes (erosion > weathering), valley floors (young surfaces)
    
    Reference: Buss et al. (2017) "Ancient saprolites reveal sustained tropical deep weathering"
    """
    # Favor gentle slopes on mid-high elevations (stable interfluves)
    interfluve = (E_norm > 0.40) & (E_norm < 0.85) & slope_class["gentle"]
    
    saprolite_favor = interfluve.astype(float)
    saprolite_favor += 0.5 * ((E_norm > 0.35) & (E_norm < 0.90)).astype(float)
    
    # Suppress on steep slopes and valley bottoms
    saprolite_favor *= (1.0 - slope_class["erosion_factor"])
    saprolite_favor *= np.clip(1.0 - (E_norm < 0.25).astype(float), 0.3, 1.0)
    
    saprolite_favor = _normalize(saprolite_favor)
    
    # Lognormal distribution (some areas have very deep weathering)
    base = np.exp(np.log(median_m) + 0.35 * rng.standard_normal(size=E_norm.shape))
    thickness = base * (0.4 + 0.6 * saprolite_favor)
    
    return np.clip(thickness, clamp[0], clamp[1])


def generate_weathered_bedrock_rind(E_norm, rng, median_m=1.8, clamp=(0.4, 6.0)):
    """
    Generate weathered bedrock rind/grus - transition zone to fresh bedrock.
    
    This is the partially fractured/altered zone between saprolite and fresh bedrock.
    Relatively uniform thickness with some spatial variability.
    
    Reference: Fletcher et al. (2006) "Bedrock weathering and the geochemical carbon cycle"
    """
    N = E_norm.shape[0]
    texture = fractional_surface(N, beta=3.0, rng=rng)
    texture = 1.0 - np.abs(2*texture - 1.0)  # Ridged texture
    
    base = np.exp(np.log(median_m) + 0.25 * rng.standard_normal(size=E_norm.shape))
    thickness = 0.6 * base + 0.4 * base * texture
    
    return np.clip(thickness, clamp[0], clamp[1])


def enforce_stratigraphic_order(layers_dict, E):
    """
    Enforce Walther's Law and stratigraphic superposition.
    
    STRATIGRAPHIC PRINCIPLES:
    1. Law of Superposition: Older (deeper) layers below younger (shallower) layers
    2. Walther's Law: Vertical succession mirrors lateral facies changes
    3. No floating layers: Each layer must rest on the layer below
    
    Expected vertical sequence (top to bottom):
    Topsoil â†’ Subsoil â†’ [Alluvium/Clay/Silt/Sand] â†’ Colluvium â†’ Saprolite â†’ 
    Weathered Bedrock â†’ [Sandstone/Shale/Limestone] â†’ Basement
    
    Reference: Boggs (2011) Ch. 2 - Sedimentary Structures
    """
    ny, nx = E.shape
    eps = 0.01  # Small gap between layers
    
    # Define top surfaces starting from ground surface
    top = {}
    top["surface"] = E.copy()
    
    # Layer order (top to bottom) - REALISTIC STRATIGRAPHY
    sequence = [
        "Topsoil",
        "Subsoil", 
        "Clay",        # Fine sediments in valleys
        "Silt",        # Intermediate sediments  
        "Sand",        # Coarse sediments in channels
        "Colluvium",   # Hillslope deposits
        "Saprolite",   # Deep weathering
        "WeatheredBR", # Weathered bedrock rind
        "Sandstone",   # Consolidated sedimentary rock
        "Shale",       # Fine-grained sedimentary rock
        "Limestone",   # Carbonate rock
        "Basement",    # Crystalline basement
    ]
    
    current_top = E.copy()
    ordered_thickness = {}
    
    for layer in sequence:
        if layer in layers_dict:
            t = layers_dict[layer]
            bottom = current_top - t
            
            # Ensure non-negative thickness
            ordered_thickness[layer] = np.maximum(current_top - bottom, 0.0)
            top[layer] = current_top.copy()
            
            # Update for next layer
            current_top = bottom - eps
    
    return ordered_thickness, top


def generate_stratigraphy(
    z_norm, rng,
    elev_range_m=700.0,
    pixel_scale_m=10.0,
    **kwargs  # Accept but ignore old parameters for backward compatibility
):
    """
    âœ… IMPROVED GEOLOGICAL LAYER GENERATOR
    
    Generates realistic stratigraphic layers using:
    - Elevation zones (lowlands, midlands, highlands)
    - Slope regimes (flat, gentle, moderate, steep)
    - Depositional environments (lacustrine, fluvial, colluvial, aeolian, residual)
    - Stratigraphic ordering (Walther's Law)
    
    INPUT (from topography generator - DO NOT MODIFY):
    - z_norm: Normalized elevation (0-1) from quantum_seeded_topography()
    - rng: Random number generator
    - elev_range_m: Total elevation range (m)
    - pixel_scale_m: Grid resolution (m/pixel)
    
    OUTPUT:
    - Thickness maps for each geological layer
    - Interface elevations (top of each layer)
    - Material properties
    - Metadata
    
    SCIENTIFIC REFERENCES:
    - Boggs (2011) "Principles of Sedimentology and Stratigraphy" 7th ed.
    - USGS Professional Paper 1396 "Sediment Transport"
    - Dunne & Leopold (1978) "Water in Environmental Planning"
    - USDA Soil Survey Manual
    """
    N = z_norm.shape[0]
    
    # Convert normalized elevation to absolute elevation (m)
    E = z_norm * elev_range_m
    E_norm = z_norm  # Keep normalized for classification
    
    # ========== STEP 1: COMPUTE TOPOGRAPHIC DERIVATIVES ==========
    dEy, dEx = np.gradient(E, pixel_scale_m, pixel_scale_m)
    slope_mag = np.hypot(dEx, dEy) + 1e-12  # m/m
    slope_deg = np.rad2deg(np.arctan(slope_mag))  # Convert to degrees
    slope_norm = _normalize(slope_mag)
    
    # Laplacian for curvature
    d2x, _ = np.gradient(dEx)
    _, d2y = np.gradient(dEy)
    laplacian = d2x + d2y
    
    # ========== STEP 2: CLASSIFY TERRAIN ==========
    elev_zones = classify_elevation_zones(E_norm)
    slope_regimes = classify_slope_regimes(slope_deg)
    
    # Identify depositional environments
    environments = compute_depositional_environments(E_norm, slope_norm, laplacian, rng)
    
    # ========== STEP 3: GENERATE UNCONSOLIDATED LAYERS ==========
    # (Based on current surface conditions - elevation + slope + environment)
    
    # TOPSOIL (O/A horizon) - universal, but thickness varies with slope
    t_topsoil_total = generate_topsoil_layer(E_norm, slope_regimes, rng, base_thickness=(0.3, 1.8))
    t_topsoil = 0.40 * t_topsoil_total  # A horizon
    t_subsoil = 0.60 * t_topsoil_total  # B horizon
    
    # FINE SEDIMENTS - low-energy environments
    t_clay = generate_clay_layer(environments, slope_regimes, E_norm, rng, max_thickness=20.0)
    t_silt = generate_silt_layer(environments, slope_regimes, E_norm, rng, max_thickness=15.0)
    
    # COARSE SEDIMENTS - moderate-high energy environments
    t_sand = generate_sand_layer(environments, slope_regimes, E_norm, rng, max_thickness=25.0)
    t_gravel = generate_gravel_layer(environments, slope_regimes, E_norm, rng, max_thickness=12.0)
    
    # HILLSLOPE DEPOSITS
    t_colluvium = generate_colluvium_layer(E_norm, slope_regimes, laplacian, rng, max_thickness=18.0)
    
    # WEATHERING PROFILE
    t_saprolite = generate_saprolite_layer(E_norm, slope_regimes, rng, median_m=6.0, clamp=(0.5, 30.0))
    t_weathered_br = generate_weathered_bedrock_rind(E_norm, rng, median_m=1.8, clamp=(0.4, 6.0))
    
    # ========== STEP 4: GENERATE BEDROCK LAYERS ==========
    # (Deeper stratigraphy - less dependent on current topography)
    
    # Simplified bedrock structure for now (can be enhanced later)
    # Use coarse elevation/slope patterns for broad structural trends
    k_coarse = max(31, int(0.15 * N) | 1)
    z_smooth = _box_blur(z_norm, k=k_coarse)
    basins = _normalize(1.0 - z_smooth)
    
    # Sedimentary package thickness (thicker in basins)
    t_sandstone = 60.0 + 40.0 * basins
    t_shale = 80.0 + 30.0 * basins  
    t_limestone = 70.0 + 30.0 * basins
    
    # Basement (crystalline bedrock)
    basement_thickness = 200.0 + 100.0 * z_norm  # Thicker under mountains (isostasy)
    
    # ========== STEP 5: ENFORCE STRATIGRAPHIC ORDER ==========
    raw_layers = {
        "Topsoil": t_topsoil,
        "Subsoil": t_subsoil,
        "Clay": t_clay,
        "Silt": t_silt, 
        "Sand": t_sand,
        "Colluvium": t_colluvium,
        "Saprolite": t_saprolite,
        "WeatheredBR": t_weathered_br,
        "Sandstone": t_sandstone,
        "Shale": t_shale,
        "Limestone": t_limestone,
        "Basement": basement_thickness,
    }
    
    thickness, interfaces = enforce_stratigraphic_order(raw_layers, E)
    
    # Add basement floor
    z_floor = float(interfaces[list(interfaces.keys())[-1]].min() - 50.0)
    interfaces["BasementFloor"] = np.full_like(E, z_floor)
    thickness["BasementFloor"] = 50.0 * np.ones_like(E)
    
    # ========== STEP 6: MATERIAL PROPERTIES ==========
    properties = {
        "Topsoil": {"erodibility": 1.00, "density": 1600, "porosity": 0.45, "K_rel": 1.00},
        "Subsoil": {"erodibility": 0.85, "density": 1700, "porosity": 0.40, "K_rel": 0.85},
        "Clay": {"erodibility": 0.80, "density": 1850, "porosity": 0.45, "K_rel": 0.80},
        "Silt": {"erodibility": 0.90, "density": 1750, "porosity": 0.42, "K_rel": 0.90},
        "Sand": {"erodibility": 0.85, "density": 1700, "porosity": 0.35, "K_rel": 0.85},
        "Colluvium": {"erodibility": 0.90, "density": 1750, "porosity": 0.35, "K_rel": 0.90},
        "Saprolite": {"erodibility": 0.70, "density": 1900, "porosity": 0.30, "K_rel": 0.70},
        "WeatheredBR": {"erodibility": 0.55, "density": 2100, "porosity": 0.20, "K_rel": 0.55},
        "Sandstone": {"erodibility": 0.30, "density": 2200, "porosity": 0.18, "K_rel": 0.30},
        "Shale": {"erodibility": 0.45, "density": 2300, "porosity": 0.12, "K_rel": 0.45},
        "Limestone": {"erodibility": 0.28, "density": 2400, "porosity": 0.08, "K_rel": 0.28},
        "Basement": {"erodibility": 0.15, "density": 2700, "porosity": 0.01, "K_rel": 0.15},
        "BasementFloor": {"erodibility": 0.02, "density": 2850, "porosity": 0.005, "K_rel": 0.02},
    }
    
    # ========== STEP 7: COMPUTE ALLUVIUM (Active channels) ==========
    # Separate from main stratigraphy - represents modern/active deposits
    catch = _box_blur(_box_blur(1.0 - slope_norm, k=7), k=13)
    wet = _normalize(catch - slope_norm)
    alluvium = np.where(wet > 0.7, np.minimum(2.0 * rng.random(size=wet.shape), 2.0), 0.0)
    
    deposits = {"Alluvium": alluvium}
    
    # ========== OUTPUT ==========
    return {
        "surface_elev": E,
        "interfaces": interfaces,
        "thickness": thickness,
        "properties": properties,
        "deposits": deposits,
        "meta": {
            "elev_range_m": elev_range_m,
            "pixel_scale_m": pixel_scale_m,
            "z_floor": z_floor,
            # Store diagnostic info
            "elevation_zones": elev_zones,
            "slope_regimes": slope_regimes,
            "environments": environments,
        }
    }


# ----------------------- Helper functions for visualization ----------------------

def compute_top_material_map(strata, min_thick=0.05):
    """
    Return a 2D array of material names representing the 'topmost' layer at each cell.
    
    Priority:
      1. Deposits (Alluvium, etc.) if present
      2. Stratigraphic layers from top down
    """
    interfaces = strata["interfaces"]
    thickness = strata["thickness"]
    deposits = strata.get("deposits", {})
    E = strata["surface_elev"]
    
    ny, nx = E.shape
    top_mat = np.empty((ny, nx), dtype=object)
    
    # Deposit order
    deposit_order = ["Alluvium"]
    deposit_order = [d for d in deposit_order if d in deposits]
    
    # Stratigraphic order (top to bottom)
    strat_order = [
        "Topsoil", "Subsoil", "Clay", "Silt", "Sand", "Colluvium",
        "Saprolite", "WeatheredBR", "Sandstone", "Shale", "Limestone", "Basement"
    ]
    strat_order = [k for k in strat_order if k in interfaces]
    
    # Initialize with basement
    top_mat[:] = "Basement"
    
    # Apply deposits where they exist
    for name in deposit_order:
        field = deposits[name]
        mask = field > min_thick
        top_mat[mask] = name
    
    # Apply stratigraphy from top down
    for i, name in enumerate(strat_order[:-1]):
        below = strat_order[i+1]
        top_here = interfaces[name]
        top_below = interfaces[below]
        thick_here = np.maximum(top_here - top_below, 0.0)
        mask = thick_here > min_thick
        
        # Only where no deposit
        no_deposit = ~np.isin(top_mat, deposit_order)
        top_mat[mask & no_deposit] = name
    
    return top_mat


# --- Cross-section vertical settings ---
MAX_SECTION_DEPTH_M = 800.0  # depth below 0 m shown in cross-sections


def plot_cross_section(strata, row=None, col=None, min_draw_thickness=0.05, ax=None):
    E = strata["surface_elev"]
    N = E.shape[0]

    # Choose section direction
    if (row is None) == (col is None):
        row = N // 2

    if row is not None:
        x = np.arange(N)
        surf = E[row, :]
        tops = {k: v[row, :] for k, v in strata["interfaces"].items()}
        axis_label = "columns (x)"
    else:
        x = np.arange(N)
        surf = E[:, col]
        tops = {k: v[:, col] for k, v in strata["interfaces"].items()}
        axis_label = "rows (y)"

    # Make elevations RELATIVE to the lowest surface point
    surf_min = float(np.nanmin(surf))
    surf_rel = surf - surf_min
    tops_rel = {k: v - surf_min for k, v in tops.items()}

    # Layer drawing order (top -> bottom)
    order = [
        "Topsoil", "Subsoil", "Clay", "Silt", "Sand", "Colluvium",
        "Saprolite", "WeatheredBR", "Sandstone", "Shale", "Limestone",
        "Basement", "BasementFloor",
    ]

    # Color map
    color_map = {
        "Topsoil": "sienna",
        "Subsoil": "peru",
        "Clay": "lightcoral",
        "Silt": "thistle",
        "Sand": "navajowhite",
        "Colluvium": "burlywood",
        "Saprolite": "khaki",
        "WeatheredBR": "darkkhaki",
        "Sandstone": "orange",
        "Shale": "slategray",
        "Limestone": "lightgray",
        "Basement": "dimgray",
        "BasementFloor": "black",
    }

    if ax is None:
        fig, ax = plt.subplots(figsize=(14, 5.5))

    handled_labels = set()

    # Draw layers bottom-up
    for i in range(len(order) - 1, 0, -1):
        above, here = order[i - 1], order[i]

        if above not in tops_rel or here not in tops_rel:
            continue

        y_top = tops_rel[above]
        y_bot = tops_rel[here]

        # Enforce minimum visible thickness
        y_bot_vis = np.where(
            (y_top - y_bot) < min_draw_thickness,
            y_top - min_draw_thickness,
            y_bot,
        )

        color = color_map.get(here, None)
        label = here if here not in handled_labels else None

        ax.fill_between(
            x, y_bot_vis, y_top,
            alpha=0.9, linewidth=0.6, zorder=5 + i,
            color=color, label=label,
        )

        if label is not None:
            handled_labels.add(label)

    # Surface line
    surface_label = "Surface" if "Surface" not in handled_labels else None
    ax.plot(x, surf_rel, linewidth=2.4, zorder=50, color="black", label=surface_label)
    if surface_label is not None:
        handled_labels.add("Surface")

    # Vertical range
    surf_top_rel = float(np.nanmax(surf_rel))
    margin = 0.05 * (surf_top_rel + MAX_SECTION_DEPTH_M)
    ax.set_ylim(-MAX_SECTION_DEPTH_M, surf_top_rel + margin)

    ax.set_title("Stratigraphic cross-section (geologically realistic)")
    ax.set_xlabel(axis_label)
    ax.set_ylabel("Elevation relative to lowest surface (m)")

    ax.legend(ncol=1, fontsize=8, framealpha=0.95, loc="center left", bbox_to_anchor=(1.02, 0.5))

    if ax is None:
        plt.tight_layout()
        plt.show()

    return ax


def plot_cross_sections_xy(strata, row=None, col=None, min_draw_thickness=0.05):
    N = strata["surface_elev"].shape[0]
    if row is None: row = N // 2
    if col is None: col = N // 2
    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(14, 11.5), constrained_layout=True)
    plot_cross_section(strata, row=row, min_draw_thickness=min_draw_thickness, ax=ax1)
    plot_cross_section(strata, col=col, min_draw_thickness=min_draw_thickness, ax=ax2)
    plt.show()


def plot_wind_structures_debug(wind_structs):
    """
    Visualize where different wind-relevant geological features occur.
    """
    E = wind_structs["E"]
    barrier_mask = wind_structs["barrier_mask"]
    channel_mask = wind_structs["channel_mask"]
    basin_mask = wind_structs["basin_mask"]

    features = np.zeros_like(E, dtype=int)
    features[barrier_mask] = 1
    features[channel_mask] = 2
    features[basin_mask] = 3

    fig, ax = plt.subplots(figsize=(6, 6))

    # Use matplotlib.colormaps instead of deprecated get_cmap
    try:
        cmap = plt.colormaps.get_cmap("tab10").resampled(4)
    except AttributeError:
        cmap = plt.cm.get_cmap("tab10", 4)

    im = ax.imshow(features, origin="lower", interpolation="nearest",
                   cmap=cmap, vmin=-0.5, vmax=3.5)

    from matplotlib.patches import Patch

    legend_patches = [
        Patch(color=cmap(1), label="Wind barriers (ridges)"),
        Patch(color=cmap(2), label="Wind channels (valleys)"),
        Patch(color=cmap(3), label="Basins / bowls"),
    ]
    ax.legend(handles=legend_patches, loc="upper right", framealpha=0.9)

    ax.set_title("Wind-relevant geological features")
    ax.set_xlabel("x (columns)")
    ax.set_ylabel("y (rows)")
    plt.tight_layout()
    plt.show()


# ------------------------------ Main Execution --------------------------------
if __name__ == "__main__":
    # Generate topography (ðŸ”’ LOCKED - DO NOT MODIFY)
    z, rng = quantum_seeded_topography(
        N=512, beta=3.2, warp_amp=0.10, ridged_alpha=0.15, random_seed=None
    )

    # Generate stratigraphy (âœ… IMPROVED with geologic principles)
    strata = generate_stratigraphy(
        z_norm=z,
        rng=rng,
        elev_range_m=700.0,
        pixel_scale_m=10.0,
    )
    
    # Re-zero vertical datum: lowest surface elevation -> 0 m
    E = strata["surface_elev"]
    offset = float(E.min())
    
    strata["surface_elev"] = E - offset
    for name, arr in strata["interfaces"].items():
        strata["interfaces"][name] = arr - offset

    # ========== VISUALIZATIONS ==========
    
    # Plot 1: Quantum-seeded topography map
    fig, ax = plt.subplots(figsize=(10, 8))
    im = ax.imshow(z, cmap='terrain', origin='lower', interpolation='bilinear')
    ax.set_title("Quantum-Seeded Topography (normalized)")
    ax.set_xlabel("X (columns)")
    ax.set_ylabel("Y (rows)")
    cbar = plt.colorbar(im, ax=ax)
    cbar.set_label("Normalized elevation")
    plt.tight_layout()
    plt.show()

    # Plot 2: Stratigraphic cross-sections
    plot_cross_sections_xy(strata)

    # Plot 3: Wind-relevant geological features
    surface_elev = strata["surface_elev"]
    wind_structs = build_wind_structures(
        surface_elev=surface_elev,
        pixel_scale_m=10.0,
        base_wind_dir_deg=270.0  # West wind
    )
    plot_wind_structures_debug(wind_structs)
    
    # Print diagnostic information
    print("\n" + "="*70)
    print("GEOLOGICAL LAYER GENERATION SUMMARY")
    print("="*70)
    print(f"Grid size: {z.shape[0]}x{z.shape[1]}")
    print(f"Elevation range: 0 - {strata['meta']['elev_range_m']:.1f} m")
    print(f"Pixel scale: {strata['meta']['pixel_scale_m']:.1f} m/pixel")
    print("\nLayer thickness statistics (meters):")
    print("-" * 70)
    for layer_name in ["Topsoil", "Subsoil", "Clay", "Silt", "Sand", "Colluvium", 
                       "Saprolite", "WeatheredBR", "Sandstone", "Shale", "Limestone"]:
        if layer_name in strata["thickness"]:
            t = strata["thickness"][layer_name]
            print(f"{layer_name:15s}: min={t.min():6.2f}  mean={t.mean():6.2f}  max={t.max():6.2f}")
    print("="*70)
