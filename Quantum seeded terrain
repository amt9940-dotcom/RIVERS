#!/usr/bin/env python3
"""
Realistic terrain + stratigraphy (now three plots):
- Surface elevation map
- One stratigraphic cross-section along X (constant row)
- One stratigraphic cross-section along Y (constant column)




Layer order (top -> bottom):
Topsoil, Subsoil, Colluvium, Saprolite, WeatheredBR (rind/grus),
Sandstone, Shale, Limestone, Basement, BasementFloor
(+ Alluvium & other deposits initialized but not plotted)
"""
from __future__ import annotations





 
# ------------------------- Standard imports -------------------------
import numpy as np
import matplotlib.pyplot as plt





# Optional quantum seeding (no auto-install)
try:
    import qiskit  # type: ignore  # noqa
    from qiskit import QuantumCircuit  # type: ignore  # noqa
    try:
        import qiskit_aer  # type: ignore  # noqa
        HAVE_QISKIT = True
    except Exception:
        HAVE_QISKIT = False
except Exception:
    HAVE_QISKIT = False
    QuantumCircuit = None  # type: ignore  # noqa


def qrng_uint32(n, nbits=32):
  """Return n uint32 from Qiskit Aer if available; else PRNG fallback."""
  if not HAVE_QISKIT:
      return np.random.default_rng().integers(0, 2**32, size=n, dtype=np.uint32)
  try:
      from qiskit_aer import Aer  # type: ignore  # noqa
  except Exception:
      try:
          from qiskit import Aer  # type: ignore  # noqa
      except Exception:
          return np.random.default_rng().integers(0, 2**32, size=n, dtype=np.uint32)
  qc = QuantumCircuit(nbits, nbits)
  qc.h(range(nbits)); qc.measure(range(nbits), range(nbits))
  backend = Aer.get_backend("qasm_simulator")
  import os
  seed_sim = int.from_bytes(os.urandom(4), "little")
  job = backend.run(qc, shots=n, memory=True, seed_simulator=seed_sim)
  mem = job.result().get_memory(qc)
  return np.array([np.uint32(int(bits[::-1], 2)) for bits in mem], dtype=np.uint32)

def rng_from_qrng(n_seeds=4, random_seed=None):
  """Random per run if random_seed=None; reproducible if you pass an int."""
  if random_seed is not None:
      return np.random.default_rng(int(random_seed))
  import os, time, hashlib
  seeds = qrng_uint32(n_seeds).tobytes()
  mix = seeds + os.urandom(16) + int(time.time_ns()).to_bytes(8, "little")
  h = hashlib.blake2b(mix, digest_size=8).digest()
  return np.random.default_rng(int.from_bytes(h, "little"))

# ------------------------ Terrain primitives ------------------------
def fractional_surface(N, beta=3.1, rng=None):
  """Power-law spectrum; higher beta => smoother large-scale terrain."""
  rng = rng or np.random.default_rng()
  kx = np.fft.fftfreq(N); ky = np.fft.rfftfreq(N)
  K = np.sqrt(kx[:, None]**2 + ky[None, :]**2); K[0, 0] = np.inf
  amp = 1.0 / (K ** (beta/2))
  phase = rng.uniform(0, 2*np.pi, size=(N, ky.size))
  spec = amp * (np.cos(phase) + 1j*np.sin(phase)); spec[0, 0] = 0.0
  z = np.fft.irfftn(spec, s=(N, N), axes=(0, 1))
  lo, hi = np.percentile(z, [2, 98])
  return np.clip((z - lo)/(hi - lo + 1e-12), 0, 1)


def bilinear_sample(img, X, Y):
  N = img.shape[0]
  x0 = np.floor(X).astype(int) % N; y0 = np.floor(Y).astype(int) % N
  x1 = (x0+1) % N; y1 = (y0+1) % N
  dx = X - np.floor(X); dy = Y - np.floor(Y)
  return ((1-dx)*(1-dy)*img[x0,y0] + dx*(1-dy)*img[x1,y0] +
          (1-dx)*dy*img[x0,y1] + dx*dy*img[x1,y1])


def domain_warp(z, rng, amp=0.12, beta=3.0):
  """Coordinate distortion; amp↑ => gnarlier micro-relief."""
  N = z.shape[0]
  u = fractional_surface(N, beta=beta, rng=rng)*2 - 1
  v = fractional_surface(N, beta=beta, rng=rng)*2 - 1
  ii, jj = np.meshgrid(np.arange(N), np.arange(N), indexing="ij")
  Xw = (ii + amp*N*u) % N; Yw = (jj + amp*N*v) % N
  return bilinear_sample(z, Xw, Yw)


def ridged_mix(z, alpha=0.18):
  """Ridge/valley sharpening; alpha↑ => craggier."""
  ridged = 1.0 - np.abs(2.0*z - 1.0)
  out = (1-alpha)*z + alpha*ridged
  lo, hi = np.percentile(out, [2, 98])
  return np.clip((out - lo)/(hi - lo + 1e-12), 0, 1)


# Optional global low-pass (smoothness control; default: off)
def lowpass2d(z, cutoff=None, rolloff=0.08):
    """Set cutoff (0..0.5) for smoothing; None disables."""
    if cutoff is None:
        return z
    Nx, Ny = z.shape
    Z = np.fft.rfft2(z)
    kx = np.fft.fftfreq(Nx)[:, None]
    ky = np.fft.rfftfreq(Ny)[None, :]
    r = np.sqrt(kx**2 + ky**2)

    m = np.ones_like(r)
    r0, w = float(cutoff), float(rolloff)
    in_roll = (r > r0) & (r < r0 + w)
    m[r >= r0 + w] = 0.0
    m[in_roll] = 0.5 * (1 + np.cos(np.pi * (r[in_roll] - r0) / w))

    zf = np.fft.irfft2(Z * m, s=z.shape)
    lo, hi = np.percentile(zf, [2, 98])
    return np.clip((zf - lo) / (hi - lo + 1e-12), 0, 1)


# Optional small Gaussian blur (last-mile softness; default: off)
def gaussian_blur(z, sigma=None):
  if sigma is None or sigma <= 0: return z
  rad = int(np.ceil(3*sigma)); x = np.arange(-rad, rad+1)
  g = np.exp(-0.5*(x/sigma)**2); g /= g.sum()
  tmp = np.zeros_like(z)
  for i,w in enumerate(g): tmp += w*np.roll(z, i-rad, axis=1)
  out = np.zeros_like(z)
  for i,w in enumerate(g): out += w*np.roll(tmp, i-rad, axis=0)
  lo, hi = np.percentile(out, [2,98])
  return np.clip((out - lo)/(hi - lo + 1e-12), 0, 1)


def quantum_seeded_topography(
  N=512, beta=3.1, warp_amp=0.12, ridged_alpha=0.18,
  *, random_seed=None, smooth_cutoff=None, smooth_rolloff=0.08, post_blur_sigma=None
):
  rng = rng_from_qrng(n_seeds=4, random_seed=random_seed)
  base_low  = fractional_surface(N, beta=beta,     rng=rng)
  base_high = fractional_surface(N, beta=beta-0.4, rng=rng)
  z = 0.65*base_low + 0.35*base_high
  z = domain_warp(z, rng=rng, amp=warp_amp, beta=beta)
  z = ridged_mix(z, alpha=ridged_alpha)
  z = lowpass2d(z, cutoff=smooth_cutoff, rolloff=smooth_rolloff)
  z = gaussian_blur(z, sigma=post_blur_sigma)
  return z, rng


# ---------------------- Stratigraphy utilities ----------------------
def _box_blur(a, k=5):
  if k <= 1: return a
  out = a.copy()
  for axis in (0,1):
      tmp = out; s = np.zeros_like(tmp)
      for i in range(-(k//2), k//2+1): s += np.roll(tmp, i, axis=axis)
      out = s/float(k)
  return out


def _normalize(x, eps=1e-12):
  lo, hi = np.percentile(x, [2,98])
  return np.clip((x - lo)/(hi - lo + eps), 0.0, 1.0)

# --------------- Wind-relevant geological features -------------------
def compute_topo_fields(surface_elev, pixel_scale_m):
    """
    Basic topographic fields from elevation only.

    Returns dict with:
      E, E_norm          : elevation (m) and normalized (0..1)
      dEx, dEy           : gradients in x (cols) and y (rows) (m/m)
      slope_mag, slope_norm
      aspect             : downslope direction (radians, 0 = +x)
      laplacian          : convex/concave indicator
    """
    E = surface_elev
    E_norm = _normalize(E)

    # gradient: np.gradient returns [d/drow, d/dcol] = [y, x]
    dEy, dEx = np.gradient(E, pixel_scale_m, pixel_scale_m)
    slope_mag = np.hypot(dEx, dEy) + 1e-12
    slope_norm = _normalize(slope_mag)

    # downslope aspect (for windward/leeward logic later)
    aspect = np.arctan2(-dEy, -dEx)

    # simple 4-neighbor Laplacian: <0 convex (ridge), >0 concave (valley)
    up    = np.roll(E, -1, axis=0)
    down  = np.roll(E,  1, axis=0)
    left  = np.roll(E,  1, axis=1)
    right = np.roll(E, -1, axis=1)
    lap = (up + down + left + right - 4.0 * E) / (pixel_scale_m**2)

    return {
        "E": E,
        "E_norm": E_norm,
        "dEx": dEx,
        "dEy": dEy,
        "slope_mag": slope_mag,
        "slope_norm": slope_norm,
        "aspect": aspect,
        "laplacian": lap,
    }


def classify_windward_leeward(dEx, dEy, slope_norm,
                              base_wind_dir_deg,
                              slope_min=0.15):
    """
    Per-cell windward / leeward classification.

    base_wind_dir_deg : direction FROM WHICH the wind blows (0° = +x, 90° = +y)
    slope_min         : ignore very flat cells
    """
    theta = np.deg2rad(base_wind_dir_deg)
    wx, wy = np.cos(theta), np.sin(theta)   # wind-from unit vector

    # component of gradient along wind-from direction
    # >0: terrain rises into the wind (windward); <0: drops away (leeward)
    up_component = dEx * wx + dEy * wy

    slope_enough = slope_norm >= slope_min
    windward_mask = slope_enough & (up_component > 0.0)
    leeward_mask  = slope_enough & (up_component < 0.0)

    return windward_mask, leeward_mask, up_component

def classify_wind_barriers(E_norm, slope_norm, laplacian, up_component,
                           elev_thresh=0.5,
                           slope_thresh=0.4,
                           convex_frac=0.4,
                           up_quantile=0.4):
    """
    Wind barriers: mountain walls that strongly lift/deflect flow.

    Conditions (now a bit looser):
      - moderately high elevation (E_norm >= elev_thresh)
      - moderately steep slopes (slope_norm >= slope_thresh)
      - convex curvature (ridge-like)
      - reasonably strong upslope component along wind
    """
    # convex threshold (more negative laplacian = more ridge-like)
    lap_convex_thr = np.quantile(laplacian, convex_frac)

    # only consider positive upslope; choose upper quantile as "strong" barrier
    mask_pos = up_component > 0.0
    if np.any(mask_pos):
        up_thr = np.quantile(up_component[mask_pos], up_quantile)
    else:
        up_thr = 0.0  # fallback: any positive upslope can count

    barrier_mask = (
        (E_norm      >= elev_thresh) &
        (slope_norm  >= slope_thresh) &
        (laplacian   <= lap_convex_thr) &
        (up_component >= up_thr)
    )
    return barrier_mask

def classify_wind_channels(E_norm, slope_norm, laplacian,
                           dEx, dEy,
                           base_wind_dir_deg,
                           elev_max=0.7,
                           concave_frac=0.6,
                           slope_min=0.03,
                           slope_max=0.7,
                           align_thresh_deg=45.0):
    """
    Wind channels: valley axes that guide flow.

    Looser conditions:
      - low to mid elevation (E_norm <= elev_max)
      - gentle to moderately steep slopes
      - concave curvature
      - downslope direction roughly ALIGNED with wind direction
    """
    theta = np.deg2rad(base_wind_dir_deg)
    wx, wy = np.cos(theta), np.sin(theta)

    # downslope direction vector
    fx, fy = -dEx, -dEy
    magf = np.hypot(fx, fy) + 1e-12
    fxu, fyu = fx / magf, fy / magf

    # cosine of angle between downslope and wind direction
    cos_ang = fxu * wx + fyu * wy
    cos_align = np.cos(np.deg2rad(align_thresh_deg))

    # concave valleys
    lap_concave_thr = np.quantile(laplacian, concave_frac)

    channel_mask = (
        (E_norm      <= elev_max) &
        (slope_norm  >= slope_min) &
        (slope_norm  <= slope_max) &
        (laplacian   >= lap_concave_thr) &
        (cos_ang     >= cos_align)
    )
    return channel_mask


def classify_basins(E_norm, slope_norm, laplacian,
                    elev_max=0.5,
                    slope_max=0.3,
                    concave_frac=0.6):
    """
    Basins / bowls:
      - relatively low elevation
      - gentle slopes
      - concave (bowls)
    (Looser thresholds so we actually catch some.)
    """
    lap_concave_thr = np.quantile(laplacian, concave_frac)
    basin_mask = (
        (E_norm      <= elev_max) &
        (slope_norm  <= slope_max) &
        (laplacian   >= lap_concave_thr)
    )
    return basin_mask


def extract_region_summaries(mask, surface_elev, pixel_scale_m, min_cells=3):
    """
    Connected-component labeling for a boolean mask.

    Uses 8-neighbor connectivity so long skinny ridges/valleys are treated
    as single structures instead of many tiny diagonal fragments.

    Each region becomes a 'structure' with:
      - indices        : (N_i, 2) array of (row, col)
      - centroid_rc    : (row, col) center
      - size_cells     : area in cells
      - mean/max/min elevation, relief
      - orientation_rad: main axis orientation (0 = +x)
      - length_scale_m : rough length along main axis (m)
    """
    ny, nx = mask.shape
    visited = np.zeros_like(mask, dtype=bool)
    regions = []

    for r0 in range(ny):
        for c0 in range(nx):
            if not mask[r0, c0] or visited[r0, c0]:
                continue

            # flood-fill with 8-neighbor connectivity
            stack = [(r0, c0)]
            visited[r0, c0] = True
            cells = []

            while stack:
                r, c = stack.pop()
                cells.append((r, c))

                for dr in (-1, 0, 1):
                    for dc in (-1, 0, 1):
                        if dr == 0 and dc == 0:
                            continue
                        rr, cc = r + dr, c + dc
                        if (
                            0 <= rr < ny and 0 <= cc < nx and
                            mask[rr, cc] and not visited[rr, cc]
                        ):
                            visited[rr, cc] = True
                            stack.append((rr, cc))

            idxs = np.array(cells, dtype=int)
            if idxs.shape[0] < min_cells:
                continue

            rows = idxs[:, 0].astype(float)
            cols = idxs[:, 1].astype(float)
            centroid_r = rows.mean()
            centroid_c = cols.mean()

            vals = surface_elev[idxs[:, 0], idxs[:, 1]]
            mean_e = float(vals.mean())
            max_e  = float(vals.max())
            min_e  = float(vals.min())
            relief = max_e - min_e

            # PCA for main axis orientation / length
            x = cols - centroid_c
            y = rows - centroid_r
            C = np.cov(np.vstack([x, y]))
            eigvals, eigvecs = np.linalg.eigh(C)
            i_max = int(np.argmax(eigvals))
            v = eigvecs[:, i_max]
            orientation = float(np.arctan2(v[1], v[0]))
            length_scale = float(2.0 * np.sqrt(max(eigvals[i_max], 0.0)) * pixel_scale_m)

            regions.append({
                "indices": idxs,
                "centroid_rc": (float(centroid_r), float(centroid_c)),
                "size_cells": int(idxs.shape[0]),
                "mean_elev_m": mean_e,
                "max_elev_m": max_e,
                "min_elev_m": min_e,
                "relief_m": relief,
                "orientation_rad": orientation,
                "length_scale_m": length_scale,
            })

    return regions


def build_wind_structures(surface_elev, pixel_scale_m, base_wind_dir_deg):
    """
    Given a topography map, classify only geological structures that change wind:
      - windward / leeward slopes
      - wind barriers (mountain walls)
      - wind channels (valley corridors)
      - basins / bowls (air pooling zones)

    Returns a dict with per-cell masks and grouped regions.
    Does NOT modify terrain or simulate weather.
    """
    topo = compute_topo_fields(surface_elev, pixel_scale_m)
    E        = topo["E"]
    E_norm   = topo["E_norm"]
    dEx      = topo["dEx"]
    dEy      = topo["dEy"]
    slope_n  = topo["slope_norm"]
    aspect   = topo["aspect"]
    lap      = topo["laplacian"]

    windward_mask, leeward_mask, up_component = classify_windward_leeward(
        dEx, dEy, slope_n, base_wind_dir_deg
    )

    barrier_mask = classify_wind_barriers(
        E_norm, slope_n, lap, up_component
    )

    channel_mask = classify_wind_channels(
        E_norm, slope_n, lap, dEx, dEy, base_wind_dir_deg
    )

    basin_mask = classify_basins(
        E_norm, slope_n, lap
    )

    barrier_regions = extract_region_summaries(barrier_mask, E, pixel_scale_m, min_cells=10)
    channel_regions = extract_region_summaries(channel_mask, E, pixel_scale_m, min_cells=10)
    basin_regions   = extract_region_summaries(basin_mask,   E, pixel_scale_m, min_cells=10)


    return {
        "E": E,
        "E_norm": E_norm,
        "slope_norm": slope_n,
        "aspect": aspect,
        "laplacian": lap,

        "windward_mask": windward_mask,
        "leeward_mask": leeward_mask,
        "up_component": up_component,

        "barrier_mask": barrier_mask,
        "channel_mask": channel_mask,
        "basin_mask": basin_mask,

        "barrier_regions": barrier_regions,   # mountain walls that block/deflect flow
        "channel_regions": channel_regions,   # valley corridors that funnel flow
        "basin_regions": basin_regions,       # bowls where air/storms pool

        "meta": {
            "pixel_scale_m": pixel_scale_m,
        },
    }


# -------------------- Wind / pseudo-low-pressure helpers --------------------
def compute_orographic_low_pressure(
    surface_elev,
    rng,
    pixel_scale_m,
    base_wind_dir_deg=45.0,
    mode="day",               # "day" ~ valley breeze, "night" ~ mountain breeze, "mixed"
    smooth_scale_rel=0.20,    # fraction of domain for large-scale smoothing
):
    """
    Build a 0..1 'low-pressure likelihood' map over mountains WITHOUT
    explicitly storing pressure, using only terrain geometry + wind direction.

    Concept:
    - Wind is driven from higher-pressure to lower-pressure areas.
      We don't model pressure; instead we mark where low-pressure *would* occur
      (ridges on windward side, heated slopes by day, cold pooled valleys at night).
    - Mountains force air to rise on windward slopes => effective low-P there.
    - Daytime: valley breeze -> upslope flow, low-P near heated slopes & ridges.
    - Nighttime: mountain breeze -> downslope flow, low-P in cold pooled valleys.

    Inputs
    ------
    surface_elev : 2D array of absolute elevation (m)
    rng          : np.random.Generator (Qiskit-seeded in your code)
    pixel_scale_m: grid spacing (m)
    base_wind_dir_deg : mean large-scale wind direction *from which* air comes
                        (0° = +x, 90° = +y)
    mode         : "day", "night", or "mixed"
    smooth_scale_rel : how coarse the large-scale basin/high field is (0..1)
    """
    z = surface_elev
    ny, nx = z.shape

    # --- gradient & slope ---
    dzdx, dzdy = np.gradient(z, pixel_scale_m, pixel_scale_m)
    slope_mag = np.sqrt(dzdx**2 + dzdy**2) + 1e-12
    slope_n   = _normalize(slope_mag)
    gentle    = 1.0 - slope_n

    # --- basic elevation normalization / basins vs highs ---
    z_smooth_k = max(5, int(smooth_scale_rel * min(nx, ny)) | 1)
    z_smooth   = _box_blur(z, k=z_smooth_k)

    elev_n = _normalize(z)            # 0 low → 1 high
    highs  = _normalize(z_smooth)     # broad highs (ridges, plateaus)
    basins = _normalize(1.0 - z_smooth)  # broad valleys/depressions

    # --- large-scale wind direction (unit vector) ---
    # wind blows from this direction into the domain
    az = np.deg2rad(base_wind_dir_deg)
    wx, wy = np.cos(az), np.sin(az)

    # directional derivative of elevation along wind direction:
    # positive where flow goes upslope (orographic lifting on windward side)
    dzw = dzdx * wx + dzdy * wy
    orographic_raw = np.maximum(dzw, 0.0)   # only upslope component
    orographic = _normalize(orographic_raw)

    # --- valley vs mountain breeze components ---
    # day: slopes heated, air rises -> low-P along sun-facing + valley-slopes
    # night: air cools, drains into valleys -> low-P pooled in basins

    # treat "sun direction" similar to wind_dir for now; you can make it separate later
    sx, sy = wx, wy
    dzs = dzdx * sx + dzdy * sy
    sun_slope_raw = np.maximum(dzs, 0.0)    # slopes facing the "sun"
    sun_slope = _normalize(sun_slope_raw)

    # Daytime valley-breeze low-P:
    # - on heated, sun-facing slopes (sun_slope)
    # - near ridge tops / high terrain (highs)
    lowP_day = _normalize(0.5 * sun_slope + 0.5 * highs)

    # Nighttime mountain-breeze low-P:
    # - in basins/valleys (basins)
    # - where slopes are gentle (cold air accumulates more easily)
    lowP_night = _normalize(0.7 * basins + 0.3 * gentle)

    # --- combine with orographic lifting (always present if mountains + wind) ---
    mode = str(mode).lower()
    if mode == "day":
        lowP = 0.50 * orographic + 0.50 * lowP_day
    elif mode == "night":
        lowP = 0.40 * orographic + 0.60 * lowP_night
    else:  # "mixed"
        lowP = 0.40 * orographic + 0.30 * lowP_day + 0.30 * lowP_night

    # small quantum-random perturbation, smoothed so it doesn't make 'salt & pepper'
    k_noise = max(7, int(0.05 * min(nx, ny)) | 1)
    rnd = rng.standard_normal(size=z.shape)
    rnd_smooth = _box_blur(rnd, k=k_noise)
    rnd_smooth = rnd_smooth / (np.std(rnd_smooth) + 1e-9)

    lowP += 0.15 * rnd_smooth  # gentle perturbation
    lowP = _normalize(lowP)

    return lowP  # 0..1: higher = more likely effective low-pressure zone


# ---------------- Physics-informed near-surface layers ----------------
def soil_thickness_from_slope(z_norm, soil_range_m=(0.3, 1.8)):
  dzdx, dzdy = np.gradient(z_norm)
  slope_mag = np.sqrt(dzdx**2 + dzdy**2)
  slope_n   = _normalize(slope_mag)
  t = soil_range_m[1] - (soil_range_m[1] - soil_range_m[0]) * slope_n
  return _box_blur(t, k=5)


def colluvium_thickness_field(
  z_norm, rng, pixel_scale_m,
  colluvium_max_m=18.0,
  *,
  w_gentle=0.35, w_curv=0.30, w_low=0.20, w_twi=0.15,
  smooth_relief_px=31, twi_k1=7, twi_k2=13,
  lognorm_sigma=0.20, floor_m=0.5, bias=1.0
):
  dzdx, dzdy = np.gradient(z_norm)
  slope_mag = np.sqrt(dzdx**2 + dzdy**2)
  slope_n   = _normalize(slope_mag)
  gentle    = 1.0 - slope_n
  d2x,_ = np.gradient(dzdx); _,d2y = np.gradient(dzdy)
  curv  = d2x + d2y
  hollows = _normalize(np.maximum(curv, 0.0))
  k = max(5, int(smooth_relief_px)|1)
  z_smooth = _box_blur(z_norm, k=k)
  lowlands = _normalize(1.0 - z_smooth)
  catch = _box_blur(_box_blur(1.0 - slope_n, k=7), k=13)
  wet = _normalize(catch - slope_n)
  w = np.array([w_gentle, w_curv, w_low, w_twi], float); w = np.clip(w,0,None); w /= (w.sum()+1e-12)
  index = _normalize(w[0]*gentle + w[1]*hollows + w[2]*lowlands + w[3]*wet)
  noise = rng.lognormal(mean=0.0, sigma=float(lognorm_sigma), size=index.shape)
  index_noisy = _normalize(index * noise)
  return bias * (floor_m + index_noisy * (colluvium_max_m - floor_m))


def saprolite_thickness_field(
  z_norm, rng,
  *,
  median_m=6.0, clamp_min=0.5, clamp_max=30.0,
  w_gentle=0.6, w_interfluve=0.4,
  relief_window_px=61, sigma=0.35
):
  dzdx, dzdy = np.gradient(z_norm)
  slope_mag = np.sqrt(dzdx**2 + dzdy**2)
  gentle = 1.0 - _normalize(slope_mag)
  k = max(5, int(relief_window_px)|1)
  z_smooth = _box_blur(z_norm, k=k)
  interfluves = _normalize(z_smooth)
  idx = _normalize(w_gentle*gentle + w_interfluve*interfluves)
  base = np.exp(np.log(median_m) + sigma * rng.standard_normal(size=idx.shape))
  return np.clip(base * (0.4 + 0.6*idx), clamp_min, clamp_max)


def weathered_rind_thickness_field(
  z_norm, rng,
  *,
  median_m=1.8, clamp_min=0.4, clamp_max=6.0,
  patch_beta=3.0, patch_alpha=0.5
):
  N = z_norm.shape[0]
  tex = fractional_surface(N, beta=patch_beta, rng=rng)
  tex = (1 - np.abs(2*tex - 1))
  base = np.exp(np.log(median_m) + 0.25 * rng.standard_normal(size=tex.shape))
  return np.clip((1 - patch_alpha) * base + patch_alpha * base * tex, clamp_min, clamp_max)

# ---------------- Glacial / aeolian deposit thickness fields ----------------
def till_thickness_field(
    z_norm, rng,
    *,
    max_till_m=25.0,
    floor_m=0.0,
    relief_window_px=61,
    lognorm_sigma=0.35,
):
    dzdx, dzdy = np.gradient(z_norm)
    slope_mag = np.sqrt(dzdx**2 + dzdy**2)
    slope_n   = _normalize(slope_mag)
    gentle    = 1.0 - slope_n

    k = max(5, int(relief_window_px) | 1)
    z_smooth = _box_blur(z_norm, k=k)
    basins   = _normalize(1.0 - z_smooth)

    index = _normalize(0.6 * basins + 0.4 * gentle)
    noise = rng.lognormal(mean=0.0, sigma=float(lognorm_sigma), size=index.shape)
    index_noisy = _normalize(index * noise)
    return floor_m + index_noisy * (max_till_m - floor_m)


def loess_thickness_field(
    z_norm, rng,
    *,
    max_loess_m=6.0,
    floor_m=0.0,
    relief_window_px=81,
    lognorm_sigma=0.30,
):
    dzdx, dzdy = np.gradient(z_norm)
    slope_mag = np.sqrt(dzdx**2 + dzdy**2)
    slope_n   = _normalize(slope_mag)
    gentle    = 1.0 - slope_n

    k = max(5, int(relief_window_px) | 1)
    z_smooth = _box_blur(z_norm, k=k)
    uplands  = _normalize(z_smooth)
    mid_uplands = uplands * (1.0 - uplands)

    index = _normalize(0.6 * gentle + 0.4 * mid_uplands)
    noise = rng.lognormal(mean=0.0, sigma=float(lognorm_sigma), size=index.shape)
    index_noisy = _normalize(index * noise)
    return floor_m + index_noisy * (max_loess_m - floor_m)


def dune_thickness_field(
    z_norm, rng,
    *,
    max_dune_m=10.0,
    floor_m=0.0,
    relief_window_px=41,
    lognorm_sigma=0.40,
):
    dzdx, dzdy = np.gradient(z_norm)
    slope_mag = np.sqrt(dzdx**2 + dzdy**2)
    slope_n   = _normalize(slope_mag)
    gentle    = 1.0 - slope_n

    k = max(5, int(relief_window_px) | 1)
    z_smooth = _box_blur(z_norm, k=k)
    lows     = _normalize(1.0 - z_smooth)

    d2x,_ = np.gradient(dzdx); _,d2y = np.gradient(dzdy)
    curv  = d2x + d2y
    convex = _normalize(np.maximum(-curv, 0.0))

    index = _normalize(0.5 * gentle + 0.3 * lows + 0.2 * convex)
    noise = rng.lognormal(mean=0.0, sigma=float(lognorm_sigma), size=index.shape)
    index_noisy = _normalize(index * noise)
    return floor_m + index_noisy * (max_dune_m - floor_m)


# ---------------- Continental crust trend helper ----------------
def crust_thickness_field(surface_elev, elev_range_m, min_factor=2.0, max_factor=5.0):
    """
    Continental-only 'effective crust thickness' field (same shape as surface_elev).
    Encodes only the pattern: higher topography → thicker crustal column.
    """
    span = max(float(elev_range_m), 1e-3)
    zmin = float(surface_elev.min())
    zmax = float(surface_elev.max())
    znorm = (surface_elev - zmin) / (zmax - zmin + 1e-12)  # 0..1
    factor = min_factor + (max_factor - min_factor) * znorm
    return span * factor

def basement_fractions_midcontinent(z_norm, slope_n, basins, rng,
                                    basalt_min=0.01, basalt_max=0.06,
                                    total_fraction=0.85):
    """
    Midcontinent-style crystalline basement composition.

    Returns 4 fraction fields (same shape as z_norm) for:
      Granite, Gneiss, Basalt, AncientCrust

    Trends:
      - High, steep areas  -> more Gneiss, less Basalt.
      - Low, gentle basins -> more Granite and a bit more Basalt.
      - AncientCrust is a modest background everywhere.

    The four fractions at each cell sum to <= total_fraction.
    Remaining thickness (if any) is generic 'Basement'.
    """
    # z_norm is already 0..1 normalized elevation
    E_norm = z_norm
    relief = slope_n

    # Base templates
    f_granite = 0.35 + 0.10 * (1.0 - basins) - 0.10 * relief
    f_gneiss  = 0.30 + 0.20 * E_norm + 0.15 * relief
    f_basalt  = 0.02 + 0.08 * basins - 0.05 * E_norm
    f_ancient = 0.12 + 0.05 * E_norm

    # Small spatially-smooth randomness so zones aren't perfectly uniform
    noise = rng.standard_normal(size=z_norm.shape)
    noise = _box_blur(noise, k=11)
    f_basalt += 0.02 * noise  # basalt patchiness, still small overall

    # Clip basalt to a realistic small range (Midcontinent = almost no basalt)
    f_basalt = np.clip(f_basalt, basalt_min, basalt_max)

    # Ensure non-negative for the other components
    f_granite = np.clip(f_granite, 0.05, None)
    f_gneiss  = np.clip(f_gneiss, 0.05, None)
    f_ancient = np.clip(f_ancient, 0.05, None)

    # Normalize so Granite+Gneiss+Basalt+AncientCrust = total_fraction at each cell
    total = f_granite + f_gneiss + f_basalt + f_ancient
    scale = total_fraction / (total + 1e-9)

    f_granite *= scale
    f_gneiss  *= scale
    f_basalt  *= scale
    f_ancient *= scale

    return f_granite, f_gneiss, f_basalt, f_ancient


# ------------------------ Layered stratigraphy -----------------------
def generate_stratigraphy(
  z_norm, rng,
  elev_range_m=700.0,
  pixel_scale_m=10.0,
  soil_range_m=(0.3, 1.8),
  # Colluvium controls
  colluvium_max_m=18.0,
  wC_gentle=0.35, wC_curv=0.30, wC_low=0.20, wC_twi=0.15,
  C_relief_px=31, C_twi_k1=7, C_twi_k2=13, C_sigma=0.20, C_floor=0.5, C_bias=1.0,
  # Saprolite controls
  sap_median=6.0, sap_min=0.5, sap_max=30.0, sap_w_gentle=0.6, sap_w_inter=0.4, sap_relief_px=61, sap_sigma=0.35,
  # Weathered rind controls
  rind_median=1.8, rind_min=0.4, rind_max=6.0, rind_patch_beta=3.0, rind_patch_alpha=0.5,
  # Competent rock package (relative proportions)
  unit_thickness_m=(90.0,110.0,100.0),  # sandstone, shale, limestone
  undulation_amp_m=10.0, undulation_beta=3.2,
  dip_deg=6.0, dip_dir_deg=45.0,
  burial_depth_m=120.0,
  bed_struct_weight=0.45,
  interface_blur_sigma=None
):
  """
  Build geologically-realistic stratigraphy using elevation and slope from topography.
  
  GEOLOGICAL PRINCIPLES (References: USGS, Principles of Sedimentology and Stratigraphy - Boggs):
  
  Layer Generation Based on Elevation and Slope:
  - SAND: Forms in low-slope, low-elevation environments (deserts, beaches, riverbanks, dunes).
          Does NOT form on steep mountain slopes or high altitudes.
  - CLAY: Forms in low-energy, flat areas (floodplains, lakes, ocean basins).
          Can appear above or below sand, but not usually above gravel.
  - GRAVEL: Forms in high-energy, sloped environments (river channels, alluvial fans).
            Must appear above bedrock, below fine-grained layers.
  - SILT: Forms in slow water bodies (lakes, estuaries). Can lie above clay or sand.
  - TOPSOIL: Appears at surface only. Forms only in moderate slope and stable terrain.
             Does NOT appear on steep cliffs or raw rock faces.
  - BEDROCK: Appears at base of all layers. Only exposed at surface in very high-slope regions.
  
  Stratigraphic Stacking Rules:
  - Typical sequence: Topsoil → Sand/Silt → Clay → Gravel → Bedrock
  - Sand can appear above clay in fluvial or coastal settings
  - Gravel always lies above bedrock, below fine-grained layers
  - Clay layers should not be placed above topsoil or gravel in normal undisturbed terrain
  
  The topography generator (quantum_seeded_topography) provides elevation and slope data,
  which this function uses to determine layer types, thicknesses, and stacking order.
  
  All randomness uses Qiskit-seeded rng, but is heavily smoothed to avoid 'spiky columns'.
  """
  N = z_norm.shape[0]
  # Absolute elevation (m)
  E = z_norm * elev_range_m

    # ---------- 1) Near-surface regolith ----------
  # Total soil thickness: thicker on low, gentle slopes
  soil_total = soil_thickness_from_slope(z_norm, soil_range_m)

  # Split into Topsoil (A) and Subsoil (B horizon).
  # You can tune top_frac (0.3–0.5) if you want a thicker A horizon.
  top_frac = 0.4
  topsoil_thick  = top_frac * soil_total
  subsoil_thick  = (1.0 - top_frac) * soil_total

  # Colluvium: gravity-driven, thickest at slope bases/hollows/lowlands.
  tC = colluvium_thickness_field(
      z_norm, rng, pixel_scale_m, colluvium_max_m,
      w_gentle=wC_gentle, w_curv=wC_curv, w_low=wC_low, w_twi=wC_twi,
      smooth_relief_px=C_relief_px, twi_k1=C_twi_k1, twi_k2=C_twi_k2,
      lognorm_sigma=C_sigma, floor_m=C_floor, bias=C_bias
  )

  # Saprolite: thick in stable, moderately elevated interfluves.
  tS = saprolite_thickness_field(
      z_norm, rng,
      median_m=sap_median, clamp_min=sap_min, clamp_max=sap_max,
      w_gentle=sap_w_gentle, w_interfluve=sap_w_inter, relief_window_px=sap_relief_px, sigma=sap_sigma
  )

  # Weathered bedrock rind / grus: patchy, overlying basement.
  tR = weathered_rind_thickness_field(
      z_norm, rng,
      median_m=rind_median, clamp_min=rind_min, clamp_max=rind_max,
      patch_beta=rind_patch_beta, patch_alpha=rind_patch_alpha
  )

  # Glacial / aeolian mantles (thickness fields; returned via 'deposits')
  t_till  = till_thickness_field(z_norm, rng)
  t_loess = loess_thickness_field(z_norm, rng)
  t_dune  = dune_thickness_field(z_norm, rng)



  # ---------- 2) Structural plane for sedimentary cover ----------
  ii, jj = np.meshgrid(np.arange(N), np.arange(N), indexing="ij")
  X = ii * pixel_scale_m
  Y = jj * pixel_scale_m
  az  = np.deg2rad(dip_dir_deg)   # map-view azimuth of dip direction
  dip = np.deg2rad(dip_deg)       # dip angle
  ux, uy = np.cos(az), np.sin(az) # unit vector along dip direction

  plane = np.tan(dip) * (ux * X + uy * Y)   # regional dip
  undul = (fractional_surface(N, beta=undulation_beta, rng=rng)*2 - 1) * undulation_amp_m
  bed_struct = plane + undul
  bed_struct_zm = bed_struct - np.mean(bed_struct)


  # ========== GEOLOGICALLY-INFORMED LAYER GENERATION ==========
  # Based on elevation and slope from topography generator
  # References: USGS, Principles of Sedimentology and Stratigraphy (Boggs)
  
  elev_span = float(E.max() - E.min() + 1e-9)
  crust_thick = crust_thickness_field(E, elev_span)  # thicker crust under high topo

  # Extract elevation and slope from topography - PRIMARY drivers for layer generation
  # These come from the topography generator and must be used to determine layers
  dEx, dEy = np.gradient(E, pixel_scale_m, pixel_scale_m)
  slope_mag = np.sqrt(dEx**2 + dEy**2) + 1e-12
  slope_n   = _normalize(slope_mag)  # 0 = gentle, 1 = steep
  gentle    = 1.0 - slope_n           # 0 = steep, 1 = gentle
  
  # Normalize elevation (0 = low, 1 = high)
  E_norm = _normalize(E)
  low_elev = 1.0 - E_norm  # 1 = low elevation, 0 = high elevation
  
  # ========== CURVATURE/CONCAVITY CALCULATION ==========
  # Calculate local curvature to identify basins (concave) vs ridges (convex)
  # This controls layer thickness: thicken in basins, thin on highs
  # Reference: Principles of Sedimentology and Stratigraphy (Boggs) - accommodation space
  
  # Laplacian: <0 = convex (ridge), >0 = concave (valley/basin)
  up    = np.roll(E, -1, axis=0)
  down  = np.roll(E,  1, axis=0)
  left  = np.roll(E,  1, axis=1)
  right = np.roll(E, -1, axis=1)
  laplacian = (up + down + left + right - 4.0 * E) / (pixel_scale_m**2)
  
  # Normalize curvature: 0 = convex (ridge), 1 = concave (basin)
  concavity = _normalize(np.maximum(laplacian, 0.0))  # Only positive (concave) values
  convexity = _normalize(np.maximum(-laplacian, 0.0))  # Only negative (convex) values
  
  # Smooth concavity to avoid noise
  concavity = _box_blur(concavity, k=5)
  
  # Very coarse topographic smooth to define basins vs highs
  k_coarse = max(31, int(0.15 * N) | 1)
  z_smooth = _box_blur(z_norm, k=k_coarse)
  basins   = _normalize(1.0 - z_smooth)   # 1 in lows, 0 on highs
  highs    = _normalize(z_smooth)         # 1 on highs
  
  # Combine concavity with basin identification for better basin geometry
  # Basins should have high concavity AND low elevation
  basin_geometry = concavity * (1.0 - E_norm)  # Strongest in concave, low areas
  ridge_geometry = convexity * E_norm  # Strongest on convex, high areas
  
  # Helper: smoothed random field (quantum-seeded, but laterally coherent)
  def smooth_random_field(k):
      noise = rng.standard_normal(size=E.shape)
      return _box_blur(noise, k=max(5, int(k) | 1))
  
  k_thick = max(15, int(0.06 * N) | 1)
  
  # ========== LAYER GENERATION BASED ON GEOLOGICAL PRINCIPLES ==========
  # Using elevation and slope to determine layer types and thicknesses
  
  # --- 1) SAND LAYER ---
  # Forms in low-slope, low-elevation environments:
  # - Deserts, beaches, riverbanks, dunes (moderate slope only)
  # - Should NOT form on steep mountain slopes or high altitudes
  # Reference: USGS - Sand deposition occurs in low-energy, flat to gently sloping areas
  sand_elev_factor = np.clip(1.0 - E_norm, 0.0, 1.0)  # Prefer low elevation
  sand_slope_factor = np.clip(1.0 - slope_n * 1.5, 0.0, 1.0)  # Prefer gentle slopes, penalize steep
  # Allow moderate slopes for dunes (0.2-0.4 normalized slope)
  dune_slope = np.clip((slope_n - 0.2) / 0.2, 0.0, 1.0) * np.clip((0.4 - slope_n) / 0.2, 0.0, 1.0)
  sand_env_raw = sand_elev_factor * (sand_slope_factor * 0.7 + dune_slope * 0.3)
  # Also favor basin margins and floodplains
  sand_env_raw += 0.3 * basins * (1.0 - basins) * gentle
  sand_env = _normalize(sand_env_raw)
  
  # --- 2) CLAY LAYER ---
  # Forms in low-energy, flat areas:
  # - Floodplains, lakes, ocean basins
  # - Can appear above or below sand, but not usually above gravel
  # Reference: Boggs - Clay settles in quiet water, low-energy environments
  clay_elev_factor = low_elev  # Prefer low elevation
  clay_slope_factor = gentle * gentle  # Strongly prefer very gentle slopes
  clay_env_raw = clay_elev_factor * clay_slope_factor
  # Favor deep basins (lakes, ocean basins)
  clay_env_raw += 0.5 * basins * basins * gentle
  clay_env = _normalize(clay_env_raw)
  
  # --- 3) GRAVEL LAYER ---
  # Forms in high-energy, sloped environments:
  # - River channels, alluvial fans, mountain base runoff zones
  # - Must appear near surface or just below loose sediment
  # - Typically found above bedrock and below sand or soil
  # Reference: USGS - Gravel requires high energy to transport, forms on slopes
  gravel_elev_factor = E_norm * 0.5 + 0.5  # Can form at various elevations
  gravel_slope_factor = np.clip(slope_n * 1.2, 0.0, 1.0)  # Prefer moderate to steep slopes
  gravel_env_raw = gravel_elev_factor * gravel_slope_factor
  # Favor areas near mountain bases (moderate elevation, moderate slope)
  mid_elev = np.clip(1.0 - np.abs(E_norm - 0.5) * 2.0, 0.0, 1.0)
  gravel_env_raw += 0.4 * mid_elev * np.clip(slope_n - 0.3, 0.0, 1.0) / 0.7
  gravel_env = _normalize(gravel_env_raw)
  
  # --- 4) SILT LAYER ---
  # Forms in slow water bodies (lakes, estuaries)
  # - Can lie above clay or sand depending on deposition history
  # Reference: Boggs - Silt is intermediate grain size, forms in quiet water
  silt_elev_factor = low_elev  # Prefer low elevation
  silt_slope_factor = gentle  # Prefer gentle slopes
  silt_env_raw = silt_elev_factor * silt_slope_factor
  # Favor areas between sand and clay environments
  silt_env_raw += 0.3 * (sand_env + clay_env) * 0.5
  silt_env = _normalize(silt_env_raw)
  
  # Calculate thicknesses for unconsolidated sediments (valley-fill)
  # These form near the surface in appropriate environments
  max_clay_m = 25.0   # Clay in deepest, flattest basins
  max_silt_m = 20.0   # Silt in quiet water areas
  max_sand_m = 30.0   # Sand in low-energy, low-slope areas
  max_gravel_m = 15.0  # Gravel in high-energy, sloped areas
  
  t_clay = max_clay_m * clay_env
  t_silt = max_silt_m * silt_env
  t_sand = max_sand_m * sand_env
  t_gravel = max_gravel_m * gravel_env
  
  # Assume ~35% of crust_thick is sedimentary cover on continental crust
  sed_frac  = 0.35
  sed_total = sed_frac * crust_thick
  
  # ========== DEPOSITIONAL ENVIRONMENT RESTRICTIONS ==========
  # CRITICAL GEOLOGICAL RULES:
  # - Evaporites: Only in flat, closed basins with restricted drainage
  # - Limestones/Dolomite: Shallow marine platforms, flat, low-lying areas
  # - Sandstone: Localized to depositional systems (fluvial, coastal, aeolian)
  # Reference: USGS Evaporite Basins - require flat, dry, enclosed basins
  
  # Identify closed basins: high concavity + low elevation + very gentle slope
  flat_mask = slope_n < 0.1  # Very flat (<10% normalized slope)
  closed_basin_mask = (basin_geometry > 0.7) & (flat_mask) & (E_norm < 0.5)  # Concave, flat, low
  
  # Facies environments for consolidated sedimentary rocks (deeper package)
  # - Sandstone: shorelines / basin margins → intermediate basinness, some slope
  # BUT: Localize to depositional systems, not everywhere
  sand_env_raw_rock  = basins * (1.0 - basins) * (0.5 + 0.5 * slope_n)
  # Reduce sandstone in high elevations and steep slopes
  sand_env_raw_rock = sand_env_raw_rock * np.clip(1.0 - E_norm * 0.8, 0.2, 1.0)
  sand_env_raw_rock = sand_env_raw_rock * np.clip(1.0 - slope_n * 0.6, 0.3, 1.0)
  
  shale_env_raw = basins  # deepening into basins (offshore muds)
  
  # Limestone/Dolomite: ONLY in flat, low-lying areas (shallow marine platforms)
  # NOT in mountains or steep slopes
  lime_env_raw = np.where(
      closed_basin_mask | (flat_mask & (E_norm < 0.4)),  # Flat, low areas only
      gentle * (1.0 - E_norm),  # Gentle, low elevation
      0.0  # Zero elsewhere
  )
  
  sand_env_rock  = _normalize(sand_env_raw_rock)
  shale_env = _normalize(shale_env_raw)
  lime_env  = _normalize(lime_env_raw)



  # ========== DEEPER CONSOLIDATED SEDIMENTARY ROCKS ==========
  # These form the deeper sedimentary package below unconsolidated valley-fill
  
  # Relative vertical proportions from unit_thickness_m
  T_sand, T_shale, T_lime = unit_thickness_m
  total_units = float(T_sand + T_shale + T_lime + 1e-12)
  f_sand  = T_sand  / total_units
  f_shale = T_shale / total_units
  f_lime  = T_lime  / total_units

  # ========== BASIN GEOMETRY: WEDGE-THICKENING INTO BASINS ==========
  # CRITICAL GEOLOGICAL RULE: Layers thicken into basins, thin over highs
  # Reference: Principles of Sedimentology and Stratigraphy (Boggs) - accommodation space
  # Use concavity to control thickness: thick in concave basins, thin on convex ridges
  
  # MUCH STRONGER thickness factor based on basin geometry
  # Concave (basins): thickness factor >> 1.0 (thicken dramatically)
  # Convex (ridges): thickness factor << 1.0 (thin dramatically)
  # This creates realistic wedge geometry where layers pinch out over highs
  basin_thickness_factor = 0.1 + 3.9 * basin_geometry  # Range: 0.1 (ridges) to 4.0 (basins) - MUCH STRONGER
  ridge_thinning_factor = 0.15 + 0.85 * (1.0 - ridge_geometry)  # Thin on ridges
  
  # Combined thickness factor: thicken dramatically in basins, thin dramatically on ridges
  accommodation_factor = basin_thickness_factor * ridge_thinning_factor
  # Smooth accommodation factor to avoid pixel-scale noise
  accommodation_factor = _box_blur(accommodation_factor, k=7)
  
  # Base thickness fields (trend) for each consolidated rock unit
  base_sandstone  = sed_total * f_sand  * (0.4 + 0.6 * sand_env_rock)
  base_shale_rock = sed_total * f_shale * (0.3 + 0.7 * shale_env)
  base_lime_rock  = sed_total * f_lime  * (0.3 + 0.7 * lime_env)

  # Quantum-smoothed variability (keeps sheets coherent, avoids "icicles")
  rnd_sand  = smooth_random_field(k_thick)
  rnd_shale = smooth_random_field(k_thick)
  rnd_lime  = smooth_random_field(k_thick)

  def apply_variation(base, rnd, amp=0.3):
      std = float(np.std(rnd) + 1e-9)
      f = 1.0 + amp * (rnd / std)
      f = np.clip(f, 0.5, 1.5)
      return np.clip(base * f, 0.0, None)

  t_sandstone_trend  = apply_variation(base_sandstone,  rnd_sand)
  t_shale_trend = apply_variation(base_shale_rock, rnd_shale)
  t_lime_trend  = apply_variation(base_lime_rock,  rnd_lime)

  # Apply basin geometry: thicken in basins, thin on ridges
  t_sandstone_trend  = t_sandstone_trend  * accommodation_factor
  t_shale_trend = t_shale_trend * accommodation_factor
  t_lime_trend  = t_lime_trend  * accommodation_factor

  # Thin units on steep slopes (erosion), but maintain minimum thickness
  # Steep slopes erode more, preserving less sediment
  thin_factor = 0.3 + 0.7 * gentle  # 1.0 on gentle, 0.3 on steep
  t_sandstone  = t_sandstone_trend  * thin_factor
  t_shale_rock = t_shale_trend * thin_factor
  
  # Limestone: ONLY in flat, low-lying areas (shallow marine platforms)
  # NOT in mountains or steep slopes
  lime_restriction = np.where(
      closed_basin_mask | (flat_mask & (E_norm < 0.4)),  # Flat, low areas only
      1.0,  # Allow limestone
      0.0   # Zero elsewhere (mountains, steep slopes)
  )
  t_lime_rock = t_lime_trend * thin_factor * lime_restriction

  # ========== STRATIGRAPHIC INTERFACE CALCULATION ==========
  # Enforce proper stacking: Topsoil → Sand/Silt → Clay → Gravel → Bedrock
  # Reference: Principles of Sedimentology and Stratigraphy (Boggs)
  # CRITICAL: All layers must be BELOW the surface elevation E
  
  Emean       = float(E.mean())
  crust_mean  = float(crust_thick.mean())
  crust_anom  = (crust_thick - crust_mean) / (crust_mean + 1e-9)

  # ========== EROSION FACTOR: Remove More on Highs/Steep Slopes ==========
  # CRITICAL GEOLOGICAL RULE: Erosion removes more material on topographic highs
  # This creates unroofing: deeper units exposed on ridges, basin margins
  # Reference: Erosion rates increase with elevation and slope (USGS)
  
  # Erosion factor: high on highs/steep slopes, low in basins
  # This will be used to "peel away" layers on topographic highs
  erosion_factor = E_norm * (0.5 + 0.5 * slope_n)  # Higher on highs and steep slopes
  erosion_factor = np.clip(erosion_factor, 0.0, 1.0)
  # Smooth erosion factor to avoid pixel-scale noise
  erosion_factor = _box_blur(erosion_factor, k=7)
  
  # ========== MOUNTAIN vs LOWLAND LITHOLOGY LOGIC ==========
  # Mountains: High elevation + steep slopes → expose igneous/metamorphic rocks
  # Lowlands: Thick sedimentary cover, basement deep
  mountain_mask = (E_norm > 0.6) & (slope_n > 0.4)  # High, steep = mountains
  lowland_mask = (E_norm < 0.4) & (slope_n < 0.3)   # Low, gentle = lowlands
  
  # In mountains: reduce sedimentary cover, expose basement/metamorphic rocks
  # In lowlands: thick sedimentary sequences, basement deep
  mountain_erosion_factor = np.where(mountain_mask, 0.2, 1.0)  # Mountains have much less sediment
  lowland_sediment_factor = np.where(lowland_mask, 1.5, 1.0)   # Lowlands have more sediment
  
  # ========== BASEMENT DEPTH ENFORCEMENT ==========
  # CRITICAL GEOLOGICAL RULE: Basement should be deep (400m+) in basins,
  # only shallow in mountain cores or heavily eroded uplifts
  # Reference: USGS Crustal Structure Overview - basement typically kilometers deep
  
  # Determine if basement should be exposed (mountain cores, shield regions)
  # Only expose basement where: high elevation AND steep slope AND convex (ridge)
  expose_basement_mask = (E_norm > 0.7) & (slope_n > 0.6) & (convexity > 0.5)
  
  # Minimum basement depth based on terrain
  # Basins: deep basement (400m+)
  # Lowlands: moderate depth (200-400m)
  # Mountains: shallow only in exposed cores (150m), otherwise deeper
  min_basement_depth_basins = 400.0  # Deep in basins
  min_basement_depth_lowlands = 250.0  # Moderate in lowlands
  min_basement_depth_mountains = np.where(
      expose_basement_mask,
      150.0,  # Shallow only in exposed mountain cores
      300.0   # Deeper in non-exposed mountain areas
  )
  
  # Combine: use basin geometry to determine minimum depth
  min_basement_depth = np.where(
      basin_geometry > 0.6,  # Strong basin signal
      min_basement_depth_basins,
      np.where(
          mountain_mask,
          min_basement_depth_mountains,
          min_basement_depth_lowlands
      )
  )
  
  # Base reference depth for sedimentary layers
  # Deeper sediment stack under thicker crust (mountain belts), shallower under thinner crust
  # In mountains, basement is closer to surface due to erosion
  # In lowlands, basement is deep due to sediment accumulation
  base_burial = np.where(
      mountain_mask,
      burial_depth_m * 0.2,  # Mountains: basement shallow (eroded)
      burial_depth_m * 1.5   # Lowlands: basement deep (sediment accumulation)
  )
  
  # Ensure base_burial respects minimum basement depth
  base_burial = np.maximum(base_burial, min_basement_depth)
  
  top_sed_ref = (
      (Emean - base_burial)
      - 0.3 * crust_anom * elev_span * mountain_erosion_factor
      + bed_struct_weight * bed_struct_zm
  )
  
  # Ensure sedimentary reference is well below surface AND respects minimum basement depth
  top_sed_ref = np.minimum(top_sed_ref, E - min_basement_depth)
  top_sed_ref = np.minimum(top_sed_ref, E - 50.0)  # At least 50m below surface

  # ---------- 5) REGOLITH STACK ABOVE SEDIMENTARY LAYERS ----------
  # Topsoil appears at surface only, forms only in moderate slope and stable terrain
  # Should not appear on steep cliffs or raw rock faces
  # CRITICAL: All layers must be BELOW surface elevation E
  eps = 0.01

  # ========== SLOPE-DEPENDENT REGOLITH THICKNESS ==========
  # CRITICAL GEOLOGICAL RULE: Regolith thickness inversely related to slope
  # Reference: USDA Soil Survey Manual - regolith rarely exceeds few meters on steep terrain
  # Colluvium accumulates at hillslope bases, not peaks
  # CRITICAL FIX: Increase base regolith thicknesses significantly to make them visible
  
  # Slope-dependent thickness factor: thin on steep slopes, thick on gentle
  # Use gentler decay: thickness = max_thickness * (1 - slope_factor * 0.7)
  # This allows more regolith on moderate slopes
  slope_decay_factor = np.clip(1.0 - slope_n * 0.7, 0.2, 1.0)  # Gentler decay, minimum 20%
  gentle_slope_factor = np.clip((0.4 - slope_n) / 0.4, 0.0, 1.0)  # On gentle to moderate slopes
  
  # A and B horizons (Topsoil and Subsoil)
  # INCREASE base thicknesses MUCH MORE - make regolith clearly visible
  topsoil_base = topsoil_thick * 4.0  # Quadruple topsoil thickness (was 2x)
  subsoil_base = subsoil_thick * 5.0   # Increase subsoil thickness significantly (was 2.5x)
  
  # Further reduce topsoil on very steep slopes (cliffs, rock faces)
  steep_cliff_mask = slope_n > 0.85  # Very steep slopes (>85% normalized) - even more restrictive
  topsoil_thick_adjusted = np.where(steep_cliff_mask, topsoil_base * 0.3, topsoil_base)
  
  # Apply slope-dependent reduction (gentler than before)
  topsoil_thick_adjusted = topsoil_thick_adjusted * slope_decay_factor
  subsoil_thick_adjusted = subsoil_base * slope_decay_factor
  
  # In mountains, reduce regolith but not as much (still need visible regolith)
  topsoil_thick_adjusted = topsoil_thick_adjusted * np.where(mountain_mask, 0.6, 1.0)  # Less reduction
  subsoil_thick_adjusted = subsoil_thick_adjusted * np.where(mountain_mask, 0.6, 1.0)  # Less reduction
  
  # Surface is E, all layers below it
  top_topsoil   = E
  top_subsoil   = top_topsoil   - topsoil_thick_adjusted
  top_colluvium = top_subsoil   - subsoil_thick_adjusted

  # Colluvium, saprolite, weathered rind
  # CRITICAL: Colluvium only forms at slope breaks (mid-to-base of slopes), not peaks
  # Use concavity to identify slope breaks (where colluvium accumulates)
  # INCREASE colluvium thickness significantly
  colluvium_slope_factor = np.clip((0.5 - slope_n) / 0.5, 0.0, 1.0)  # On moderate slopes
  colluvium_location_factor = (0.3 + 0.7 * concavity) * colluvium_slope_factor  # At slope breaks
  
  tC_adjusted = tC * 4.0 * colluvium_location_factor * np.where(mountain_mask, 0.5, 1.0)  # Quadruple thickness (was 2x)
  tC_adjusted = np.clip(tC_adjusted, 0.0, 40.0)  # Max 40m colluvium (increased from 30m)
  
  # Saprolite: thickest on gentle, stable interfluves
  # INCREASE saprolite thickness MUCH MORE
  tS_adjusted = tS * 5.0 * gentle_slope_factor * np.where(mountain_mask, 0.6, 1.0)  # Much more thickness (was 2.5x)
  
  top_saprolite = top_colluvium - tC_adjusted
  top_rind      = top_saprolite - tS_adjusted
  
  # Ensure regolith doesn't go below reasonable depth - INCREASE max depth significantly
  top_rind = np.maximum(top_rind, E - 80.0)  # Max 80m regolith (increased from 50m)

  # ========== STRATIGRAPHIC STACKING WITH GEOLOGICAL RULES ==========
  # Order from top to bottom: Topsoil → Sand/Silt → Clay → Gravel → Bedrock
  # But allow variations based on depositional environment:
  # - Sand can appear above clay in fluvial/coastal settings
  # - Gravel always lies above bedrock, below fine-grained layers
  # CRITICAL: All layers must be BELOW surface elevation E
  
  # In mountains: minimal valley-fill (erosion dominates)
  # In lowlands: thick valley-fill sediments
  t_clay_adjusted = t_clay * np.where(mountain_mask, 0.1, 1.0)
  t_silt_adjusted = t_silt * np.where(mountain_mask, 0.1, 1.0)
  t_sand_adjusted = t_sand * np.where(mountain_mask, 0.1, 1.0)
  t_gravel_adjusted = t_gravel * np.where(mountain_mask, 0.2, 1.0)
  
  # Determine stacking order based on environmental factors
  # In areas with high sand_env and low clay_env: Sand → Clay → Gravel
  # In areas with high clay_env: Clay → Sand → Gravel (clay deposited first)
  # Gravel always near bottom (above bedrock)
  
  # Calculate which layer should be on top based on depositional environment
  sand_dominates = sand_env > clay_env
  clay_dominates = clay_env > sand_env * 1.2
  
  # Valley-fill unconsolidated sediments stack below weathered rind
  # Start from weathered rind and stack downward
  # Clay typically forms first (deepest, quietest water)
  top_clay = top_rind - t_clay_adjusted
  
  # Silt can be above or below clay depending on environment
  top_silt = np.where(
      sand_dominates,
      top_clay - t_silt_adjusted,  # Silt above clay in high-energy settings
      top_rind - t_silt_adjusted   # Silt near top in low-energy settings
  )
  top_silt = np.minimum(top_silt, top_clay)  # Ensure proper ordering
  
  # Sand can appear above clay in fluvial/coastal settings
  top_sand = np.where(
      sand_dominates,
      top_rind - t_sand_adjusted,  # Sand on top in high-energy settings
      top_silt - t_sand_adjusted   # Sand below silt/clay in low-energy settings
  )
  top_sand = np.minimum(top_sand, np.minimum(top_silt, top_clay))
  
  # Gravel always above bedrock, below fine-grained layers
  top_gravel = np.minimum(top_sand, top_clay) - t_gravel_adjusted
  
  # Ensure all valley-fill is below surface
  top_clay = np.minimum(top_clay, E - eps)
  top_silt = np.minimum(top_silt, E - eps)
  top_sand = np.minimum(top_sand, E - eps)
  top_gravel = np.minimum(top_gravel, E - eps)
  
  # Find the deepest valley-fill layer
  top_valley_fill_bottom = np.minimum(np.minimum(top_sand, top_clay), np.minimum(top_silt, top_gravel))
  
  # ---------- 4) DEEPER CONSOLIDATED SEDIMENTARY ROCKS ----------
  # These form below the unconsolidated valley-fill sediments
  # In mountains: reduce sedimentary thickness, expose igneous/metamorphic
  # In lowlands: thick sedimentary sequences
  
  # ========== BREAK UP UNIFORM SANDSTONE INTO MULTIPLE INTERVALS ==========
  # CRITICAL FIX: Instead of one giant sandstone slab, create multiple variable intervals
  # separated by shale/silt/mudstone layers
  # This creates realistic stratigraphic sequences, not one mega-layer
  
  # REDUCE GLOBAL FRACTION OF SANDSTONE
  # Reduce base sandstone thickness significantly
  base_sandstone = base_sandstone * 0.4  # Reduce to 40% of original
  
  # Sandstone restriction: MUCH stronger - localize to specific environments
  sandstone_elevation_factor = np.clip(1.0 - E_norm * 1.5, 0.0, 1.0)  # Very strong reduction in high elevations
  sandstone_slope_factor = np.clip(1.0 - slope_n * 1.2, 0.0, 1.0)  # Very strong reduction on steep slopes
  sandstone_basin_factor = basins * (1.0 - basins)  # Prefer basin margins, not everywhere
  sandstone_restriction = sandstone_elevation_factor * sandstone_slope_factor * (0.2 + 0.8 * sandstone_basin_factor)
  
  # ========== DRAMATIC THINNING OVER HIGHS ==========
  # CRITICAL: Sandstone must thin dramatically over highs and pinch out completely
  # Use convexity (ridges) and erosion factor to create strong thinning
  ridge_thinning = np.clip(1.0 - convexity * 2.0, 0.0, 1.0)  # Thin dramatically on ridges
  high_elevation_thinning = np.clip(1.0 - E_norm * 1.5, 0.0, 1.0)  # Thin on highs
  erosion_thinning = np.clip(1.0 - erosion_factor * 1.2, 0.0, 1.0)  # Thin where erosion is high
  
  # Combined thinning factor: sandstone pinches out on highs
  sandstone_thinning_factor = ridge_thinning * high_elevation_thinning * erosion_thinning
  sandstone_thinning_factor = np.clip(sandstone_thinning_factor, 0.0, 1.0)
  # Smooth to avoid pixel-scale noise
  sandstone_thinning_factor = _box_blur(sandstone_thinning_factor, k=7)
  
  # Create VARIABLE sandstone intervals - not uniform
  # Use multiple random fields to create patchy distribution
  sandstone_patch1 = smooth_random_field(k_thick * 2)  # Coarse patches
  sandstone_patch2 = smooth_random_field(k_thick * 3)  # Finer patches
  sandstone_variability = _normalize(sandstone_patch1 + sandstone_patch2 * 0.5)
  
  # Sandstone only appears where restriction AND variability AND thinning allow
  # On highs, sandstone_thinning_factor approaches 0, pinching out sandstone
  sandstone_presence = sandstone_restriction * sandstone_variability * sandstone_thinning_factor
  sandstone_presence = np.clip(sandstone_presence, 0.0, 1.0)
  
  # Adjust sedimentary rock thickness based on terrain
  # Sandstone: MUCH more variable, localized, thins dramatically on highs, pinches out
  t_sandstone_adjusted = t_sandstone * np.where(mountain_mask, 0.05, lowland_sediment_factor) * sandstone_presence * accommodation_factor
  
  # Shale: thickens strongly in basins, forms between sandstone intervals
  # Also thin on highs due to erosion
  shale_thinning = np.clip(1.0 - erosion_factor * 0.8, 0.2, 1.0)  # Less thinning than sandstone
  t_shale_adjusted = t_shale_rock * np.where(mountain_mask, 0.2, lowland_sediment_factor) * accommodation_factor * shale_thinning
  
  # Limestone: only in appropriate environments
  t_lime_adjusted = t_lime_rock * np.where(mountain_mask, 0.2, lowland_sediment_factor) * accommodation_factor
  
  # Smooth thicknesses to prevent pixel-scale noise
  t_sandstone_adjusted = _box_blur(t_sandstone_adjusted, k=5)
  t_shale_adjusted = _box_blur(t_shale_adjusted, k=5)
  t_lime_adjusted = _box_blur(t_lime_adjusted, k=5)
  
  # Base interfaces for consolidated sedimentary rocks
  # CRITICAL: When sandstone pinches out on highs, deeper units (shale, limestone) should be exposed
  # The natural calculation (top_shale = top_sandstone - t_sandstone) already handles this:
  # when t_sandstone is small, shale is closer to surface
  top_sandstone_raw = np.minimum(top_sed_ref, top_valley_fill_bottom - eps)
  top_shale_raw     = top_sandstone_raw - t_sandstone_adjusted
  top_limestone_raw = top_shale_raw     - t_shale_adjusted
  
  # On highly eroded highs, ensure deeper units can reach closer to surface
  # This creates unroofing: shale/limestone exposed on ridges
  high_erosion_mask = erosion_factor > 0.7  # Highly eroded areas
  # On highs, allow shale to be closer to surface (erosion has removed overlying sandstone)
  top_shale_raw = np.where(
      high_erosion_mask,
      np.maximum(top_shale_raw, top_valley_fill_bottom - 10.0),  # Closer to surface on highs
      top_shale_raw
  )
  
  # ========== MOUNTAIN LITHOLOGY VARIETY ==========
  # In mountains: expose igneous/metamorphic rocks, reduce sedimentary cover
  # Create varied rock sequences in mountains (granite, gneiss, schist, etc.)
  
  # Mountain rock type distribution based on elevation and slope
  # High, steep mountains → more igneous (granite, diorite)
  # Moderate mountains → metamorphic (gneiss, schist)
  mountain_igneous_factor = np.clip((E_norm - 0.6) * (slope_n - 0.4) * 2.0, 0.0, 1.0)
  mountain_metamorphic_factor = np.clip(E_norm * slope_n * 1.5, 0.0, 1.0)
  
  # In mountains, reduce sedimentary package and bring basement/metamorphic closer
  mountain_sediment_reduction = np.where(mountain_mask, 0.1, 1.0)
  
  # Calculate basement depth - deep in lowlands, shallow ONLY in exposed mountain cores
  # CRITICAL: Use minimum basement depth calculated earlier
  # Basement should be hundreds of meters deep in basins
  basement_depth_lowlands = np.maximum(burial_depth_m * 1.5, min_basement_depth_lowlands)  # ~250m+ in lowlands
  basement_depth_mountains = np.where(
      expose_basement_mask,
      min_basement_depth_mountains,  # Shallow only in exposed cores
      min_basement_depth_mountains * 2.0  # Deeper in non-exposed mountain areas
  )
  
  basement_depth = np.where(
      mountain_mask,
      basement_depth_mountains,
      np.maximum(basement_depth_lowlands, min_basement_depth)  # Use terrain-based minimum
  )
  
  top_basement_raw = top_limestone_raw - t_lime_adjusted
  # CRITICAL: Ensure basement is at appropriate depth (respects minimum basement depth)
  top_basement_raw = np.minimum(
      top_basement_raw,
      E - basement_depth
  )
  # Additional constraint: basement must be at least min_basement_depth below surface
  top_basement_raw = np.minimum(
      top_basement_raw,
      E - min_basement_depth
  )
  
  # ========== AGGRESSIVELY SMOOTH BASEMENT SURFACE ==========
  # CRITICAL FIX: Smooth basement surface to prevent spiky chimneys
  # Basement surfaces should be smooth laterally, not pixel-scale sawtooth
  smooth_k_basement = max(15, int(0.1 * N) | 1)  # Large smoothing kernel for basement
  top_basement_raw = _box_blur(top_basement_raw, k=smooth_k_basement)
  
  # Ensure consolidated rocks stay below unconsolidated sediments and respect ordering
  top_sandstone = np.minimum(top_sandstone_raw, top_valley_fill_bottom - eps)
  top_shale     = np.minimum(top_shale_raw,     top_sandstone - eps)
  top_limestone = np.minimum(top_limestone_raw, top_shale - eps)
  top_basement  = np.minimum(top_basement_raw,  top_limestone - eps)
  
  # Smooth sedimentary interfaces to prevent pixel-scale noise
  top_sandstone = _box_blur(top_sandstone, k=7)
  top_shale = _box_blur(top_shale, k=7)
  top_limestone = _box_blur(top_limestone, k=7)
  
  # Re-enforce ordering after smoothing
  top_sandstone = np.minimum(top_sandstone, top_valley_fill_bottom - eps)
  top_shale = np.minimum(top_shale, top_sandstone - eps)
  top_limestone = np.minimum(top_limestone, top_shale - eps)
  top_basement = np.minimum(top_basement, top_limestone - eps)
  
  # Ensure ALL layers are below surface
  top_sandstone = np.minimum(top_sandstone, E - eps)
  top_shale     = np.minimum(top_shale,     E - eps)
  top_limestone = np.minimum(top_limestone, E - eps)
  top_basement  = np.minimum(top_basement,  E - eps)

  # Add intermediate sedimentary layers with proper thickness
  # In mountains: create varied sedimentary sequences (folded/thrust belts)
  # Mountains can have: sandstone, shale, limestone in folded sequences
  # CRITICAL: Apply erosion factor to thin these layers on highs
  
  # Conglomerate: forms in high-energy settings, often in mountain foothills
  # In mountains: moderate thickness (alluvial fans, mountain-front deposits)
  # Thin dramatically on highs due to erosion
  conglomerate_thinning = np.clip(1.0 - erosion_factor * 1.0, 0.0, 1.0)
  t_conglomerate = np.where(mountain_mask, 12.0, 10.0) * gravel_env * conglomerate_thinning
  t_conglomerate = np.clip(t_conglomerate, 0.0, 50.0)  # Max constraint
  top_conglomerate = top_shale - t_conglomerate
  
  # Mudstone: fine-grained, deep basins
  # In mountains: thin (eroded), but can be present in folded sequences
  # Less thinning than coarse-grained units
  mudstone_thinning = np.clip(1.0 - erosion_factor * 0.7, 0.3, 1.0)
  t_mudstone = np.where(mountain_mask, 8.0, 20.0) * clay_env * mudstone_thinning
  t_mudstone = np.clip(t_mudstone, 0.0, 40.0)  # Max constraint
  top_mudstone = top_conglomerate - t_mudstone
  
  # Siltstone: intermediate grain size
  # In mountains: moderate thickness in sedimentary sequences
  siltstone_thinning = np.clip(1.0 - erosion_factor * 0.8, 0.2, 1.0)
  t_siltstone = np.where(mountain_mask, 10.0, 15.0) * silt_env * siltstone_thinning
  t_siltstone = np.clip(t_siltstone, 0.0, 30.0)  # Max constraint
  top_siltstone = top_mudstone - t_siltstone
  
  # Dolomite: carbonate platform
  # ONLY in flat, low-lying areas (shallow marine platforms)
  # NOT in mountains or steep slopes
  t_dolomite = np.where(
      closed_basin_mask | (flat_mask & (E_norm < 0.4)),  # Flat, low areas only
      np.where(mountain_mask, 0.0, 12.0) * lime_env * 0.3,  # Zero in mountains
      0.0  # Zero elsewhere
  )
  t_dolomite = np.clip(t_dolomite, 0.0, 50.0)  # Max constraint
  top_dolomite = top_siltstone - t_dolomite
  
  # Evaporite: ONLY in closed basins (flat, dry, enclosed basins with restricted drainage)
  # CRITICAL: Evaporites require closed basins - NO outflow
  # Reference: USGS Evaporite Basins - require flat, dry, enclosed basins
  t_evaporite = np.where(
      closed_basin_mask,  # ONLY in closed basins
      np.where(mountain_mask, 0.0, 8.0) * basins * 0.2,  # Zero in mountains
      0.0  # Zero elsewhere (including mountains, steep slopes, open basins)
  )
  t_evaporite = np.clip(t_evaporite, 0.0, 20.0)  # Max constraint
  top_evaporite = top_dolomite - t_evaporite
  
  # Smooth intermediate layers to prevent spikes
  top_conglomerate = _box_blur(top_conglomerate, k=3)
  top_mudstone = _box_blur(top_mudstone, k=3)
  top_siltstone = _box_blur(top_siltstone, k=3)
  top_dolomite = _box_blur(top_dolomite, k=3)
  top_evaporite = _box_blur(top_evaporite, k=3)
  
  # Ensure all intermediate layers are below surface and properly ordered
  top_conglomerate = np.minimum(top_conglomerate, E - eps)
  top_mudstone = np.minimum(top_mudstone, top_conglomerate - eps)
  top_siltstone = np.minimum(top_siltstone, top_mudstone - eps)
  top_dolomite = np.minimum(top_dolomite, top_siltstone - eps)
  top_evaporite = np.minimum(top_evaporite, top_dolomite - eps)

  # ---------- 5b) CRYSTALLINE BASEMENT PARTITION WITH MOUNTAIN VARIETY ----------
  # Total crystalline column between the evaporites and the top of generic Basement
  # CRITICAL: Constrain basement_total to prevent spikes
  basement_total_raw = top_evaporite - top_basement
  # Maximum basement thickness: ~500m in lowlands, ~200m in mountains
  max_basement_thick = np.where(mountain_mask, 200.0, 500.0)
  basement_total = np.clip(np.maximum(basement_total_raw, 5.0), 5.0, max_basement_thick)
  
  # Smooth basement_total to prevent spikes
  basement_total = _box_blur(basement_total, k=5)

  # ========== REALISTIC MOUNTAIN LITHOLOGY WITH VERTICAL VARIETY ==========
  # Mountains have varied vertical sequences:
  # - Thin regolith (erosion)
  # - Exposed bedrock layers: granite, gneiss, schist, folded sedimentary sequences
  # - Layers should vary vertically, not just one type
  
  # Mountain rock type factors based on elevation and slope
  # High, steep mountains → more igneous (granite, diorite)
  # Moderate mountains → metamorphic (gneiss, schist)
  # Lower mountain slopes → folded sedimentary sequences
  mountain_igneous_pref = np.clip((E_norm - 0.6) * (slope_n - 0.4) * 3.0, 0.0, 1.0)
  mountain_metamorphic_pref = np.clip(E_norm * slope_n * 2.0, 0.0, 1.0)
  mountain_sedimentary_pref = np.clip((1.0 - E_norm) * slope_n * 1.5, 0.0, 1.0)  # Lower slopes
  
  # Base fractions from midcontinent function
  f_granite_base, f_gneiss_base, f_basalt_base, f_ancient_base = basement_fractions_midcontinent(
      z_norm,   # normalized elevation (0..1)
      slope_n,  # present-day slope (0..1)
      basins,   # 0 on highs, 1 in deep basins
      rng
  )
  
  # ========== MOUNTAIN LAYER VARIETY ==========
  # Create varied vertical sequences in mountains:
  # 1. Upper mountain (high elevation): Granite → Gneiss → Schist
  # 2. Mid mountain: Gneiss → Schist → Folded sedimentary layers
  # 3. Lower mountain: Folded sedimentary → Metamorphic → Granite
  
  # In mountains, create more varied fractions
  # Upper mountains: more granite and gneiss
  # Mid mountains: more gneiss and schist (metamorphic)
  # Lower mountains: mix of sedimentary and metamorphic
  
  # Granite: more in high, steep mountains
  f_granite = np.where(
      mountain_mask,
      f_granite_base * (1.0 + mountain_igneous_pref * 0.8),  # More granite in high mountains
      f_granite_base
  )
  
  # Gneiss: common throughout mountains, especially mid-elevation
  f_gneiss = np.where(
      mountain_mask,
      f_gneiss_base * (1.0 + mountain_metamorphic_pref * 0.7),  # More gneiss in mountains
      f_gneiss_base
  )
  
  # Add Schist layer in mountains (metamorphic rock common in mountain belts)
  # Schist forms from metamorphism of shale/mudstone
  f_schist = np.where(
      mountain_mask,
      mountain_metamorphic_pref * 0.25,  # Up to 25% schist in mountains
      0.05  # Small amount in lowlands
  )
  
  # Basalt: less in mountains, more in lowlands
  f_basalt = np.where(
      mountain_mask,
      f_basalt_base * 0.2,  # Less basalt in mountains
      f_basalt_base
  )
  
  # Ancient crust: slightly less in mountains
  f_ancient = np.where(
      mountain_mask,
      f_ancient_base * 0.7,  # Less ancient crust in mountains
      f_ancient_base
  )
  
  # Normalize fractions to sum to reasonable total (accounting for schist)
  total_frac = f_granite + f_gneiss + f_schist + f_basalt + f_ancient
  scale = 0.85 / (total_frac + 1e-9)  # Target 85% of basement
  f_granite *= scale
  f_gneiss *= scale
  f_schist *= scale
  f_basalt *= scale
  f_ancient *= scale

  # ========== AGGRESSIVELY SMOOTH BASEMENT FRACTIONS ==========
  # CRITICAL FIX: Smooth fractions BEFORE converting to thicknesses
  # This prevents pixel-scale spiky chimneys in basement
  # Use large smoothing kernel to create smooth, laterally continuous basement
  smooth_k = max(11, int(0.08 * N) | 1)  # Much larger smoothing kernel
  f_granite = _box_blur(f_granite, k=smooth_k)
  f_gneiss = _box_blur(f_gneiss, k=smooth_k)
  f_schist = _box_blur(f_schist, k=smooth_k)
  f_basalt = _box_blur(f_basalt, k=smooth_k)
  f_ancient = _box_blur(f_ancient, k=smooth_k)
  
  # Renormalize after smoothing
  total_frac_smooth = f_granite + f_gneiss + f_schist + f_basalt + f_ancient
  scale_smooth = 0.85 / (total_frac_smooth + 1e-9)
  f_granite *= scale_smooth
  f_gneiss *= scale_smooth
  f_schist *= scale_smooth
  f_basalt *= scale_smooth
  f_ancient *= scale_smooth

  # Convert fractions into actual thicknesses (m) with maximum constraints
  # Constrain individual layer thicknesses to prevent spikes
  max_layer_thick = np.where(mountain_mask, 150.0, 300.0)  # Max thickness per layer
  
  t_granite = np.clip(basement_total * f_granite, 0.0, max_layer_thick)
  t_gneiss  = np.clip(basement_total * f_gneiss, 0.0, max_layer_thick)
  t_schist  = np.clip(basement_total * f_schist, 0.0, max_layer_thick)
  t_basalt  = np.clip(basement_total * f_basalt, 0.0, max_layer_thick)
  t_ancient = np.clip(basement_total * f_ancient, 0.0, max_layer_thick)
  
  # Smooth thicknesses AGGRESSIVELY to prevent spikes
  t_granite = _box_blur(t_granite, k=smooth_k)
  t_gneiss = _box_blur(t_gneiss, k=smooth_k)
  t_schist = _box_blur(t_schist, k=smooth_k)
  t_basalt = _box_blur(t_basalt, k=smooth_k)
  t_ancient = _box_blur(t_ancient, k=smooth_k)

  # Build interfaces top-down from the evaporites
  # Create varied vertical stacking in mountains
  top_granite        = top_evaporite - t_granite
  top_gneiss         = top_granite  - t_gneiss
  top_schist         = top_gneiss   - t_schist
  top_basalt         = top_schist   - t_basalt
  top_ancient_crust  = top_basalt   - t_ancient
  
  # ========== SMOOTH BASEMENT INTERFACES AGGRESSIVELY ==========
  # CRITICAL: Smooth interfaces to prevent vertical chimneys
  # This creates smooth basement surfaces, not pixel-scale sawtooth
  top_granite = _box_blur(top_granite, k=smooth_k)
  top_gneiss = _box_blur(top_gneiss, k=smooth_k)
  top_schist = _box_blur(top_schist, k=smooth_k)
  top_basalt = _box_blur(top_basalt, k=smooth_k)
  top_ancient_crust = _box_blur(top_ancient_crust, k=smooth_k)
  
  # Ensure all basement layers are below surface and properly ordered
  top_granite = np.minimum(top_granite, E - eps)
  top_gneiss = np.minimum(top_gneiss, top_granite - eps)
  top_schist = np.minimum(top_schist, top_gneiss - eps)
  top_basalt = np.minimum(top_basalt, top_schist - eps)
  top_ancient_crust = np.minimum(top_ancient_crust, top_basalt - eps)


  # ---------- 6) Basement floor ----------
  z_floor = float(top_basement.min() - 0.2 * elev_span)
  top_basement_floor = np.full_like(top_basement, z_floor)

  # ---------- 7) FINAL CONSTRAINT: Ensure ALL layers below surface ----------
  # CRITICAL: No layer can appear above the surface elevation E
  # This is a fundamental geological constraint
  
  # Constrain all interfaces to be below surface
  top_topsoil = np.minimum(top_topsoil, E)
  top_subsoil = np.minimum(top_subsoil, E - eps)
  top_colluvium = np.minimum(top_colluvium, E - eps)
  top_saprolite = np.minimum(top_saprolite, E - eps)
  top_rind = np.minimum(top_rind, E - eps)
  top_sand = np.minimum(top_sand, E - eps)
  top_silt = np.minimum(top_silt, E - eps)
  top_clay = np.minimum(top_clay, E - eps)
  top_gravel = np.minimum(top_gravel, E - eps)
  top_sandstone = np.minimum(top_sandstone, E - eps)
  top_conglomerate = np.minimum(top_conglomerate, E - eps)
  top_shale = np.minimum(top_shale, E - eps)
  top_mudstone = np.minimum(top_mudstone, E - eps)
  top_siltstone = np.minimum(top_siltstone, E - eps)
  top_limestone = np.minimum(top_limestone, E - eps)
  top_dolomite = np.minimum(top_dolomite, E - eps)
  top_evaporite = np.minimum(top_evaporite, E - eps)
  top_granite = np.minimum(top_granite, E - eps)
  top_gneiss = np.minimum(top_gneiss, E - eps)
  top_basalt = np.minimum(top_basalt, E - eps)
  top_ancient_crust = np.minimum(top_ancient_crust, E - eps)
  top_basement = np.minimum(top_basement, E - eps)

  # ---------- 7b) Optional smoothing of rock interfaces ----------
  if interface_blur_sigma is not None and interface_blur_sigma > 0:
      def blur(a): return gaussian_blur(a, sigma=interface_blur_sigma)
      top_sandstone = blur(top_sandstone)
      top_shale     = blur(top_shale)
      top_limestone = blur(top_limestone)
      top_basement  = blur(top_basement)
      # Re-enforce ordering AND surface constraint after blur
      top_sandstone = np.minimum(top_sandstone, np.minimum(top_rind - eps, E - eps))
      top_shale     = np.minimum(top_shale,     np.minimum(top_sandstone - eps, E - eps))
      top_limestone = np.minimum(top_limestone, np.minimum(top_shale - eps, E - eps))
      top_basement  = np.minimum(top_basement,  np.minimum(top_limestone - eps, E - eps))
      z_floor = float(top_basement.min() - 0.2 * elev_span)
      top_basement_floor = np.full_like(top_basement, z_floor)

  # ---------- 8) THICKNESS RASTERS WITH STRATIGRAPHIC ORDERING ----------
  # Calculate final thicknesses ensuring proper geological stacking
  # Order: Topsoil → Subsoil → Colluvium → Saprolite → WeatheredBR → 
  #        Sand/Silt → Clay → Gravel → Sandstone → Shale → Limestone → Basement
  
  # CRITICAL: Add maximum thickness constraints to prevent spikes
  # Maximum layer thicknesses (meters) to prevent unrealistic spikes
  max_thickness = {
      "Topsoil": 2.0, "Subsoil": 3.0, "Colluvium": 20.0, "Saprolite": 35.0, "WeatheredBR": 10.0,
      "Sand": 35.0, "Silt": 25.0, "Clay": 30.0, "Gravel": 20.0,
      "Sandstone": 150.0, "Conglomerate": 50.0, "Shale": 120.0, "Mudstone": 40.0,
      "Siltstone": 30.0, "Limestone": 100.0, "Dolomite": 50.0, "Evaporite": 20.0,
      "Granite": 200.0, "Gneiss": 200.0, "Schist": 150.0, "Basalt": 100.0,
      "AncientCrust": 300.0, "Basement": 500.0
  }
  
  # Handle variable stacking: Sand can be above or below Clay depending on environment
  # Determine which is actually on top at each location
  sand_above_clay = top_sand > top_clay
  
  thickness = {
      # Regolith
      "Topsoil":       np.maximum(top_topsoil     - top_subsoil,         0.0),
      "Subsoil":       np.maximum(top_subsoil     - top_colluvium,       0.0),
      "Colluvium":     np.maximum(top_colluvium   - top_saprolite,       0.0),
      "Saprolite":     np.maximum(top_saprolite   - top_rind,            0.0),
      "WeatheredBR":   np.maximum(top_rind        - top_valley_fill_bottom, 0.0),

      # Valley-fill unconsolidated sediments (order depends on environment)
      # Sand: thickness depends on whether it's above or below clay/silt
      "Sand":          np.where(
          sand_above_clay,
          np.maximum(top_sand - np.maximum(top_silt, top_clay), 0.0),  # Sand above
          np.maximum(top_sand - top_gravel, 0.0)  # Sand below
      ),
      
      # Silt: intermediate layer
      "Silt":          np.where(
          sand_above_clay,
          np.maximum(top_silt - top_clay, 0.0),  # Silt below sand
          np.maximum(top_silt - top_sand, 0.0)  # Silt above sand
      ),
      
      # Clay: typically deepest of fine-grained sediments
      "Clay":          np.where(
          sand_above_clay,
          np.maximum(top_clay - top_gravel, 0.0),  # Clay below sand/silt
          np.maximum(top_clay - top_gravel, 0.0)  # Clay below sand
      ),
      
      # Gravel: always above bedrock, below fine-grained layers
      "Gravel":        np.maximum(top_gravel - top_sandstone, 0.0),

      # Sedimentary Units (existing deeper package)
      "Sandstone":     np.maximum(top_sandstone     - top_conglomerate,    0.0),
      "Conglomerate":  np.maximum(top_conglomerate  - top_shale,           0.0),
      "Shale":         np.maximum(top_shale         - top_mudstone,        0.0),
      "Mudstone":      np.maximum(top_mudstone      - top_siltstone,       0.0),
      "Siltstone":     np.maximum(top_siltstone     - top_limestone,       0.0),
      "Limestone":     np.maximum(top_limestone     - top_dolomite,        0.0),
      "Dolomite":      np.maximum(top_dolomite      - top_evaporite,       0.0),
      "Evaporite":     np.maximum(top_evaporite     - top_granite,         0.0),

      # Crystalline Units
      "Granite":       np.maximum(top_granite     - top_gneiss,          0.0),
      "Gneiss":        np.maximum(top_gneiss      - top_schist,           0.0),
      "Schist":        np.maximum(top_schist      - top_basalt,          0.0),
      "Basalt":        np.maximum(top_basalt      - top_ancient_crust,   0.0),
      "AncientCrust":  np.maximum(top_ancient_crust - top_basement,      0.0),

      # Base
      "Basement":      np.maximum(top_basement    - top_basement_floor,  0.0),
      "BasementFloor": np.maximum(top_basement_floor - (top_basement_floor - 0.0), 0.0),
  }
  
  # Apply maximum thickness constraints to prevent spikes
  for layer_name, max_thick in max_thickness.items():
      if layer_name in thickness:
          thickness[layer_name] = np.clip(thickness[layer_name], 0.0, max_thick)
  
  # Smooth thicknesses to prevent sharp spikes
  for layer_name in thickness:
      if layer_name not in ["BasementFloor"]:  # Don't smooth the floor
          thickness[layer_name] = _box_blur(thickness[layer_name], k=3)


  interfaces = {
      # Regolith
      "Topsoil":       top_topsoil,
      "Subsoil":       top_subsoil,
      "Colluvium":     top_colluvium,
      "Saprolite":     top_saprolite,
      "WeatheredBR":   top_rind,

      # Valley-fill unconsolidated sediments
      "Sand":          top_sand,
      "Silt":          top_silt,
      "Clay":          top_clay,
      "Gravel":        top_gravel,

      # Sedimentary Units
      "Sandstone":     top_sandstone,
      "Conglomerate":  top_conglomerate,
      "Shale":         top_shale,
      "Mudstone":      top_mudstone,
      "Siltstone":     top_siltstone,
      "Limestone":     top_limestone,
      "Dolomite":      top_dolomite,
      "Evaporite":     top_evaporite,

      # Crystalline Units
      "Granite":       top_granite,
      "Gneiss":        top_gneiss,
      "Schist":        top_schist,
      "Basalt":        top_basalt,
      "AncientCrust":  top_ancient_crust,

      # Base
      "Basement":      top_basement,
      "BasementFloor": top_basement_floor,
  }





    # ---------- 9) Alluvium (channels / floodplains) ----------
  dzdx, dzdy = np.gradient(z_norm)
  slope_mag2 = np.sqrt(dzdx**2 + dzdy**2)
  slope_n2   = _normalize(slope_mag2)
  catch = _box_blur(_box_blur(1.0 - slope_n2, k=7), k=13)
  wet = _normalize(catch - slope_n2)
  alluvium = np.where(
      wet > 0.7,
      np.minimum(2.0 * rng.random(size=wet.shape), 2.0),
      0.0,
  )

  # Glacial / aeolian + fluvial deposit rasters (thickness in m)
  deposits = {
      "Till":     t_till,
      "Loess":    t_loess,
      "DuneSand": t_dune,
      "Alluvium": alluvium,
  }


  # ---------- 10) Material properties ----------
  properties = {
      # REGOLITH / SOIL
      "Topsoil": {
          "erodibility": 1.00,  # high: silty/loamy, organic-rich
          "density":     1600,
          "porosity":    0.45,
          "K_rel":       1.00,
      },
      "Subsoil": {
          # B horizon: more clay/oxides, less organic, somewhat less erodible
          "erodibility": 0.85,
          "density":     1700,
          "porosity":    0.40,
          "K_rel":       0.85,
      },
      "Colluvium": {
          "erodibility": 0.90,  # very erodible slope wash
          "density":     1750,
          "porosity":    0.35,
          "K_rel":       0.90,
      },
      "Alluvium": {
          # river & floodplain deposits
          "erodibility": 0.95,
          "density":     1700,
          "porosity":    0.40,
          "K_rel":       0.95,
      },
            "Clay": {
          # fine-grained basin / lake / floodplain deposits
          "erodibility": 0.80,
          "density":     1850,
          "porosity":    0.45,
          "K_rel":       0.80,
      },
      "Silt": {
          # slightly coarser than clay; common in overbank / distal deposits
          "erodibility": 0.90,
          "density":     1750,
          "porosity":    0.42,
          "K_rel":       0.90,
      },
      "Sand": {
          # non-dune fluvial sand; looser than sandstone
          "erodibility": 0.85,
          "density":     1700,
          "porosity":    0.35,
          "K_rel":       0.85,
      },
      "Gravel": {
          # coarse-grained, high-energy deposits; forms in river channels, alluvial fans
          "erodibility": 0.70,
          "density":     2000,
          "porosity":    0.30,
          "K_rel":       0.70,
      },
      "Till": {
          # glacial rubble; can be quite erodible or resistant depending on compaction
          "erodibility": 0.75,
          "density":     1900,
          "porosity":    0.25,
          "K_rel":       0.75,
      },
      "Loess": {
          # wind-blown silt; extremely erodible once exposed
          "erodibility": 1.05,
          "density":     1550,
          "porosity":    0.50,
          "K_rel":       1.05,
      },
      "DuneSand": {
          # loose, well-sorted sand; very low cohesion
          "erodibility": 0.95,
          "density":     1650,
          "porosity":    0.40,
          "K_rel":       0.95,
      },

      # WEATHERED ROCK
      "Saprolite": {
          "erodibility": 0.70,
          "density":     1900,
          "porosity":    0.30,
          "K_rel":       0.70,
      },
      "WeatheredBR": {
          # weathered bedrock / rind
          "erodibility": 0.55,
          "density":     2100,
          "porosity":    0.20,
          "K_rel":       0.55,
      },

      # WEAK CLASTIC (MUDSTONE / SHALE)
      "Shale": {
          "erodibility": 0.45,
          "density":     2300,
          "porosity":    0.12,
          "K_rel":       0.45,
      },
      "Mudstone": {
          # treated as an alias of Shale for now
          "erodibility": 0.45,
          "density":     2300,
          "porosity":    0.12,
          "K_rel":       0.45,
      },

      # MEDIUM CLASTIC (SILTSTONE)
      "Siltstone": {
          # intermediate between shale and sandstone
          "erodibility": 0.35,
          "density":     2350,
          "porosity":    0.10,
          "K_rel":       0.35,
      },

      # STRONGER CLASTIC (SANDSTONE / CONGLOMERATE)
      "Sandstone": {
          "erodibility": 0.30,
          "density":     2200,
          "porosity":    0.18,
          "K_rel":       0.30,
      },
      "Conglomerate": {
          # often slightly more resistant than sandstone (coarse clasts + cement)
          "erodibility": 0.25,
          "density":     2300,
          "porosity":    0.16,
          "K_rel":       0.25,
      },

      # CARBONATES
      "Limestone": {
          "erodibility": 0.28,  # mechanically strong, but dissolves chemically
          "density":     2400,
          "porosity":    0.08,
          "K_rel":       0.28,
      },
      "Dolomite": {
          # often slightly more resistant than limestone
          "erodibility": 0.24,
          "density":     2450,
          "porosity":    0.06,
          "K_rel":       0.24,
      },

      # EVAPORITES (GYPSUM / HALITE)
      "Evaporite": {
          # mechanically moderate but chemically super erodible
          "erodibility": 0.90,
          "density":     2200,
          "porosity":    0.15,
          "K_rel":       0.90,
      },

      # CRYSTALLINE BASEMENT (GRANITE / GNEISS / BASALT) + AGGREGATE
      "Basement": {
          # generic crystalline basement
          "erodibility": 0.15,
          "density":     2700,
          "porosity":    0.01,
          "K_rel":       0.15,
      },
      "Granite": {
          "erodibility": 0.15,
          "density":     2700,
          "porosity":    0.01,
          "K_rel":       0.15,
      },
      "Gneiss": {
          "erodibility": 0.16,
          "density":     2750,
          "porosity":    0.01,
          "K_rel":       0.16,
      },
      "Schist": {
          # Metamorphic rock common in mountain belts; foliated, can be erodible
          "erodibility": 0.20,
          "density":     2700,
          "porosity":    0.02,
          "K_rel":       0.20,
      },
      "Basalt": {
          # dense mafic volcanic; often forms very resistant flows
          "erodibility": 0.12,
          "density":     2950,
          "porosity":    0.02,
          "K_rel":       0.12,
      },

      # BASEMENT FLOOR (numerical bottom)
      "BasementFloor": {
          "erodibility": 0.02,
          "density":     2850,
          "porosity":    0.005,
          "K_rel":       0.02,
      },
  }

  facies_controls = {
      "basins":       basins,    # 0 (high areas) → 1 (deep basins)
      "highs":        highs,     # 0 (basins)    → 1 (high areas)
      "paleo_slope":  slope_n,   # 0 (gentle)   → 1 (steep)
      "elevation":    E_norm,    # 0 (low elev) → 1 (high elev) - from topography
      "slope_mag":    slope_n,   # 0 (gentle)   → 1 (steep) - from topography
      "sand_env":     sand_env,   # Sand depositional environment (0-1)
      "clay_env":     clay_env,   # Clay depositional environment (0-1)
      "gravel_env":   gravel_env, # Gravel depositional environment (0-1)
      "silt_env":     silt_env,   # Silt depositional environment (0-1)
      "mountain_mask": mountain_mask.astype(float),  # 1 in mountains, 0 elsewhere
      "lowland_mask": lowland_mask.astype(float),    # 1 in lowlands, 0 elsewhere
  }


  return {
      "surface_elev": E,
      "interfaces": interfaces,
      "thickness": thickness,
      "properties": properties,
      "alluvium_init": alluvium,
      "deposits": deposits,
      "meta": {
          "elev_range_m": elev_range_m,
          "pixel_scale_m": pixel_scale_m,
          "dip_deg": dip_deg,
          "dip_dir_deg": dip_dir_deg,
          "unit_thickness_m": unit_thickness_m,
          "burial_depth_m": burial_depth_m,
          "bed_struct_weight": bed_struct_weight,
          "z_floor": z_floor
      }
  }

def compute_top_material_map(strata, min_thick=0.05):
    """
    Return a 2D array of material names representing
    the 'topmost' layer at each (row, col) cell.

    Priority:
      1. Glacial/aeolian/fluvial deposits (if local thickness > 0)
      2. Stratigraphic interfaces, from Topsoil down to Basement
      3. Never returns 'BasementFloor' by design.
    """
    interfaces = strata["interfaces"]
    thickness  = strata["thickness"]
    deposits   = strata.get("deposits", {})
    E          = strata["surface_elev"]

    ny, nx = E.shape
    top_mat = np.empty((ny, nx), dtype=object)

    # 1) Deposits priority (if you want a different order, change this list)
    deposit_order = ["Loess", "DuneSand", "Till", "Alluvium"]
    deposit_order = [d for d in deposit_order if d in deposits]

    # 2) Stratigraphic order, top -> bottom (excluding BasementFloor)
    strat_order = [
        # Surface/regolith
        "Topsoil",
        "Subsoil",
        "Colluvium",
        "Saprolite",
        "WeatheredBR",

        # Valley-fill unconsolidated sediments
        "Sand",
        "Silt",
        "Clay",
        "Gravel",

        # Sedimentary package
        "Sandstone",
        "Conglomerate",
        "Shale",
        "Mudstone",
        "Siltstone",
        "Limestone",
        "Dolomite",
        "Evaporite",

        # Crystalline/metamorphic
        "Granite",
        "Gneiss",
        "Schist",
        "Basalt",
        "AncientCrust",

        # Base
        "Basement",
        # BasementFloor is never used as a top surface
    ]


    strat_order = [k for k in strat_order if k in interfaces]

    # Initialize with a safe default (Basement, not BasementFloor)
    top_mat[:] = "Basement"

    # a) Deposits where they actually exist
    for name in deposit_order:
        field = deposits[name]
        mask = field > min_thick
        top_mat[mask] = name

    # b) Stratigraphy – from top layer downward
    for i, name in enumerate(strat_order[:-1]):
        below = strat_order[i+1]
        top_here   = interfaces[name]
        top_below  = interfaces[below]
        thick_here = np.maximum(top_here - top_below, 0.0)
        mask = thick_here > min_thick

        # Only overwrite where no deposit already sits
        no_deposit = ~np.isin(top_mat, deposit_order)
        top_mat[mask & no_deposit] = name

    # c) Any cells still not in the strat_order get Basement as fallback.
    # (BasementFloor is intentionally never used as a top material.)
    not_assigned = ~np.isin(top_mat, deposit_order + strat_order)
    top_mat[not_assigned] = "Basement"

    return top_mat

def get_geologic_stack(elevation, slope, noise=0.5, max_depth=1000):
    layers = []

    # Classify terrain
    if elevation < 200:
        terrain = 'valley'
    elif elevation < 500:
        terrain = 'plateau'
    else:
        terrain = 'mountain'

    # Use slope to adjust soil/sediment thickness
    slope = min(slope, 45)
    erosion_factor = np.interp(slope, [0, 45], [1.0, 0.2])

    depth = 0

    def add_layer(name, thickness):
        nonlocal depth
        thickness = int(thickness)
        if depth + thickness > max_depth:
            thickness = max_depth - depth
        if thickness > 0:
            layers.append((name, thickness))
            depth += thickness

    # Terrain-dependent layering
    if terrain == 'valley':
        add_layer("topsoil", 5 * erosion_factor)
        add_layer("clay", 25 * erosion_factor)
        add_layer("silt", 40 * erosion_factor)
        add_layer("sandstone", 100 + noise * 30)
        add_layer("shale", 100)
        add_layer("limestone", 100)
        add_layer("schist", 150)
        add_layer("gneiss", 200)
        add_layer("granite", max_depth - depth)

    elif terrain == 'plateau':
        add_layer("topsoil", 3 * erosion_factor)
        add_layer("sand", 15)
        add_layer("sandstone", 80)
        add_layer("basalt", 100)
        add_layer("schist", 150)
        add_layer("granite", max_depth - depth)

    elif terrain == 'mountain':
        add_layer("thin_soil", 1 * erosion_factor)
        add_layer("volcanic_rock", 20)
        add_layer("schist", 200)
        add_layer("gneiss", 300)
        add_layer("granite", 300)
        add_layer("ancient_continental_crust", max_depth - depth)

    return layers


def compute_top_facies_map(strata, min_thick=0.05):
    """
    Use:
      - top layer map from compute_top_material_map(...)
      - facies_controls (basins, highs, paleo_slope)
    to assign a *facies-level* lithology per cell, e.g.:
      Sandstone package -> Sandstone vs Conglomerate
      Shale package     -> Shale vs Mudstone vs Siltstone
      Limestone package -> Limestone vs Dolomite vs Evaporite
    """
    top_layer = compute_top_material_map(strata, min_thick=min_thick)
    controls  = strata.get("facies_controls", {})

    basins      = controls.get("basins", None)
    highs       = controls.get("highs", None)
    paleo_slope = controls.get("paleo_slope", None)

    # If controls are missing for some reason, just return the layer map.
    if basins is None or highs is None or paleo_slope is None:
        return top_layer

    ny, nx = top_layer.shape
    facies = np.empty_like(top_layer, dtype=object)

    # Precompute masks for environment
    deep_basin   = basins > 0.7
    mid_basin    = (basins > 0.4) & (basins <= 0.7)
    shallow_basin= (basins > 0.2) & (basins <= 0.4)
    high_zone    = highs > 0.6

    steep        = paleo_slope > 0.5
    moderate_slp = (paleo_slope > 0.2) & (paleo_slope <= 0.5)
    gentle       = paleo_slope <= 0.2

    # Start with a copy: default facies = top layer name
    facies[:] = top_layer

    # --- SANDSTONE PACKAGE: Sandstone vs Conglomerate ---
    mask_sand = top_layer == "Sandstone"
    # Conglomerates near steep paleo-slopes (coarse clastics near steep source)
    mask_cong = mask_sand & (steep | (mid_basin & moderate_slp))
    facies[mask_cong] = "Conglomerate"
    # Remaining sandstone cells keep "Sandstone"

    # --- SHALE PACKAGE: Shale vs Mudstone vs Siltstone ---
    mask_shale = top_layer == "Shale"
    # Deepest basins => Mudstone (very fine, quiet water)
    mask_mud = mask_shale & deep_basin
    facies[mask_mud] = "Mudstone"
    # Highs and gentle slopes => Siltstone (slightly coarser, near shore/shallows)
    mask_silt = mask_shale & high_zone & gentle
    facies[mask_silt] = "Siltstone"
    # Everything else in shale package stays "Shale"

    # --- LIMESTONE PACKAGE: Limestone vs Dolomite vs Evaporite ---
    mask_lime = top_layer == "Limestone"
    # Evaporites only in deepest basins (restricted marine / sabkha-style)
    mask_evap = mask_lime & deep_basin
    facies[mask_evap] = "Evaporite"
    # Dolomite on persistent highs (carbonate platforms)
    mask_dolo = mask_lime & high_zone & (gentle | moderate_slp)
    facies[mask_dolo] = "Dolomite"
    # Remaining limestone stays "Limestone"

    # Everything else (Topsoil, Subsoil, Colluvium, Saprolite, Till, etc.)
    # already has a meaningful name and remains unchanged.
    return facies

# --- Cross-section vertical settings ---
MAX_SECTION_DEPTH_M = 800.0  # depth below 0 m shown in cross-sections


# ----------------------- Cross-section plotting ----------------------
def plot_cross_section(strata, row=None, col=None, min_draw_thickness=0.05, ax=None):
    E = strata["surface_elev"]
    N = E.shape[0]

    # Choose section direction
    if (row is None) == (col is None):
        row = N // 2

    if row is not None:
        x = np.arange(N)
        surf = E[row, :]
        tops = {k: v[row, :] for k, v in strata["interfaces"].items()}
        axis_label = "columns (x)"
    else:
        x = np.arange(N)
        surf = E[:, col]
        tops = {k: v[:, col] for k, v in strata["interfaces"].items()}
        axis_label = "rows (y)"

    # --- Make elevations RELATIVE to the lowest surface point ---
    # 0 = lowest surface; negative = depth below that
    surf_min = float(np.nanmin(surf))
    surf_rel = surf - surf_min
    tops_rel = {k: v - surf_min for k, v in tops.items()}

    # Layer drawing order (top -> bottom)
    order = [
        "Topsoil",
        "Subsoil",
        "Colluvium",
        "Saprolite",
        "WeatheredBR",

        # valley-fill sediments
        "Sand",
        "Silt",
        "Clay",
        "Gravel",

        # sedimentary package
        "Sandstone",
        "Conglomerate",
        "Shale",
        "Mudstone",
        "Siltstone",
        "Limestone",
        "Dolomite",
        "Evaporite",

        # crystalline/metamorphic
        "Granite",
        "Gneiss",
        "Schist",
        "Basalt",
        "AncientCrust",

        # base
        "Basement",
        "BasementFloor",
    ]

    # Color map (bright, distinct; only BasementFloor is very dark)
    color_map = {
        "Topsoil":      "sienna",
        "Subsoil":      "peru",
        "Colluvium":    "burlywood",
        "Saprolite":    "burlywood",
        "WeatheredBR":  "khaki",

        "Sand":         "navajowhite",
        "Silt":         "thistle",
        "Clay":         "lightcoral",
        "Gravel":       "tan",

        "Sandstone":    "orange",
        "Conglomerate": "chocolate",
        "Shale":        "slategray",
        "Mudstone":     "rosybrown",
        "Siltstone":    "lightsteelblue",
        "Limestone":    "lightgray",
        "Dolomite":     "gainsboro",
        "Evaporite":    "plum",

        "Granite":      "lightpink",
        "Gneiss":       "violet",
        "Schist":       "mediumpurple",
        "Basalt":       "royalblue",
        "AncientCrust": "darkseagreen",

        "Basement":     "dimgray",
        "BasementFloor":"black",
    }

    if ax is None:
        fig, ax = plt.subplots(figsize=(14, 5.5))

    handled_labels = set()

    # --- Draw layers bottom-up using RELATIVE tops ---
    for i in range(len(order) - 1, 0, -1):  # bottom-up
        above, here = order[i - 1], order[i]

        if above not in tops_rel or here not in tops_rel:
            continue  # skip layers missing in interfaces

        y_top = tops_rel[above]
        y_bot = tops_rel[here]

        # Enforce minimum visible thickness
        y_bot_vis = np.where(
            (y_top - y_bot) < min_draw_thickness,
            y_top - min_draw_thickness,
            y_bot,
        )

        color = color_map.get(here, None)
        label = here if here not in handled_labels else None

        ax.fill_between(
            x,
            y_bot_vis,
            y_top,
            alpha=0.9,
            linewidth=0.6,
            zorder=5 + i,
            color=color,
            label=label,
        )

        if label is not None:
            handled_labels.add(label)

    # --- Surface line (only one legend entry) ---
    surface_label = "Surface" if "Surface" not in handled_labels else None
    ax.plot(
        x,
        surf_rel,
        linewidth=2.4,
        zorder=50,
        color="black",
        label=surface_label,
    )
    if surface_label is not None:
        handled_labels.add("Surface")

    # --- Vertical range: from -maxdepth m to top surface (relative) ---
    surf_top_rel = float(np.nanmax(surf_rel))
    margin = 0.05 * (surf_top_rel + MAX_SECTION_DEPTH_M)  # ~5% headroom
    ax.set_ylim(-MAX_SECTION_DEPTH_M, surf_top_rel + margin)

    ax.set_title("Stratigraphic cross-section (top→bottom)")
    ax.set_xlabel(axis_label)
    ax.set_ylabel("Elevation relative to lowest surface (m)")

    ax.legend(
        ncol=1,
        fontsize=8,
        framealpha=0.95,
        loc="center left",
        bbox_to_anchor=(1.02, 0.5),
    )

    if ax is None:
        plt.tight_layout()
        plt.show()

    return ax


# Convenience: plot both orthogonal sections
def plot_cross_sections_xy(strata, row=None, col=None, min_draw_thickness=0.05):
  N = strata["surface_elev"].shape[0]
  if row is None: row = N // 2
  if col is None: col = N // 2
  fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(14, 11.5), constrained_layout=True)
  # Along X (constant row)
  plot_cross_section(strata, row=row, min_draw_thickness=min_draw_thickness, ax=ax1)
  # Along Y (constant column)
  plot_cross_section(strata, col=col, min_draw_thickness=min_draw_thickness, ax=ax2)
  plt.show()

# ------------- Wind-relevant geological feature plot (separate block) -------------
def plot_wind_structures_debug(wind_structs):
    """
    Visualize where different wind-relevant geological features occur.

    Uses the masks from build_wind_structures(...) and makes a categorical map
    the same size as the terrain.
    """
    E = wind_structs["E"]
    barrier_mask = wind_structs["barrier_mask"]
    channel_mask = wind_structs["channel_mask"]
    basin_mask   = wind_structs["basin_mask"]

    # integer feature codes (0 = none, 1 = barrier, 2 = channel, 3 = basin)
    features = np.zeros_like(E, dtype=int)
    features[barrier_mask] = 1
    features[channel_mask] = 2
    features[basin_mask]   = 3

    fig, ax = plt.subplots(figsize=(6, 6))

    # Use a discrete tab10 colormap with 4 entries: indices 0,1,2,3
    cmap = plt.cm.get_cmap("tab10", 4)

    # vmin/vmax make sure ints 0,1,2,3 map cleanly to those 4 colors
    im = ax.imshow(features,
                   origin="lower",
                   interpolation="nearest",
                   cmap=cmap,
                   vmin=-0.5, vmax=3.5)

    from matplotlib.patches import Patch

    # IMPORTANT: use the SAME indices the image uses: 1, 2, 3
    legend_patches = [
        Patch(color=cmap(1), label="Wind barriers (ridges)"),   # code 1
        Patch(color=cmap(2), label="Wind channels (valleys)"),  # code 2
        Patch(color=cmap(3), label="Basins / bowls"),           # code 3
    ]
    ax.legend(handles=legend_patches, loc="upper right", framealpha=0.9)

    ax.set_title("Wind-relevant geological features")
    ax.set_xlabel("x (columns)")
    ax.set_ylabel("y (rows)")
    plt.tight_layout()
    plt.show()



# ------------------------------ Master Terrain --------------------------------
if __name__ == "__main__":
  z, rng = quantum_seeded_topography(
      N=512, beta=3.2, warp_amp=0.10, ridged_alpha=0.15, random_seed=None
  )




  strata = generate_stratigraphy(
      z_norm=z, rng=rng,
      elev_range_m=700.0, pixel_scale_m=10.0,
      soil_range_m=(0.3, 1.8),
      colluvium_max_m=18.0, wC_gentle=0.35, wC_curv=0.30, wC_low=0.20, wC_twi=0.15,
      C_relief_px=31, C_twi_k1=7, C_twi_k2=13, C_sigma=0.20, C_floor=0.5, C_bias=1.0,
      sap_median=6.0, sap_min=0.5, sap_max=30.0, sap_w_gentle=0.6, sap_w_inter=0.4, sap_relief_px=61, sap_sigma=0.35,
      rind_median=1.8, rind_min=0.4, rind_max=6.0, rind_patch_beta=3.0, rind_patch_alpha=0.5,
      unit_thickness_m=(90.0,110.0,100.0),
      undulation_amp_m=10.0, undulation_beta=3.2,
      dip_deg=6.0, dip_dir_deg=45.0,
      burial_depth_m=120.0, bed_struct_weight=0.45
  )
      # --- Re-zero vertical datum: lowest surface elevation -> 0 m ---
  E = strata["surface_elev"]
  offset = float(E.min())  # global lowest surface

  strata["surface_elev"] = E - offset
  for name, arr in strata["interfaces"].items():
      strata["interfaces"][name] = arr - offset



  # Plot 1: Quantum-seeded topography map
  fig, ax = plt.subplots(figsize=(10, 8))
  im = ax.imshow(z, cmap='terrain', origin='lower', interpolation='bilinear')
  ax.set_title("Quantum-Seeded Topography (normalized)")
  ax.set_xlabel("X (columns)")
  ax.set_ylabel("Y (rows)")
  cbar = plt.colorbar(im, ax=ax)
  cbar.set_label("Normalized elevation")
  plt.tight_layout()
  plt.show()

  # Plot 2: Stratigraphic cross-sections
  plot_cross_sections_xy(strata)

  # --- Generate realistic underground material stacks (1000m deep) ---
  elev_range_m = strata["meta"]["elev_range_m"]
  pixel_scale_m = strata["meta"]["pixel_scale_m"]

  # Convert normalized terrain `z` into real elevation (meters)
  elevation_map = z * elev_range_m

  # Compute slope map (gradient magnitude)
  gy, gx = np.gradient(elevation_map, pixel_scale_m)
  slope_map = np.sqrt(gx**2 + gy**2)

  # Plot 3: Wind-relevant geological features
  surface_elev = strata["surface_elev"]
  wind_structs = build_wind_structures(
      surface_elev=surface_elev,
      pixel_scale_m=pixel_scale_m,
      base_wind_dir_deg=270.0  # West wind
  )
  plot_wind_structures_debug(wind_structs)

  # Prepare storage: terrain_layers[y][x] = list of (material, thickness)
def stratigraphy_from_demo(z_norm, rng_obj, **kwargs):
    """
    Ignore z_norm and rng_obj; reuse the precomputed `strata` from the demo.
    """
    return strata
    return strata

def get_geologic_stack(elevation, slope, noise=0.5, max_depth=1000):
    layers = []

    # Classify terrain
    if elevation < 200:
        terrain = 'valley'
    elif elevation < 500:
        terrain = 'plateau'
    else:
        terrain = 'mountain'

    # Use slope to adjust soil/sediment thickness
    slope = min(slope, 45)
    erosion_factor = np.interp(slope, [0, 45], [1.0, 0.2])

    depth = 0

    def add_layer(name, thickness):
        nonlocal depth
        thickness = int(thickness)
        if depth + thickness > max_depth:
            thickness = max_depth - depth
        if thickness > 0:
            layers.append((name, thickness))
            depth += thickness

    # Terrain-dependent layering
    if terrain == 'valley':
        add_layer("topsoil", 5 * erosion_factor)
        add_layer("clay", 25 * erosion_factor)
        add_layer("silt", 40 * erosion_factor)
        add_layer("sandstone", 100 + noise * 30)
        add_layer("shale", 100)
        add_layer("limestone", 100)
        add_layer("schist", 150)
        add_layer("gneiss", 200)
        add_layer("granite", max_depth - depth)

    elif terrain == 'plateau':
        add_layer("topsoil", 3 * erosion_factor)
        add_layer("sand", 15)
        add_layer("sandstone", 80)
        add_layer("basalt", 100)
        add_layer("schist", 150)
        add_layer("granite", max_depth - depth)

    elif terrain == 'mountain':
        add_layer("thin_soil", 1 * erosion_factor)
        add_layer("volcanic_rock", 20)
        add_layer("schist", 200)
        add_layer("gneiss", 300)
        add_layer("granite", 300)
        add_layer("ancient_continental_crust", max_depth - depth)

    return layers
